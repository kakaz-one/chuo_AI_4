# 小課題1：Python基礎問題と解説

---

## 問1. ミュータブル（変更可能）なデータ型

**問題：** 以下のうち、ミュータブル(変更可能)であるデータ型を選択せよ。

1. リスト
2. 文字列
3. タプル
4. 整数

**正解：1. リスト**

### 解説
Pythonのデータ型は、ミュータブル（変更可能）とイミュータブル（変更不可）に分類される。

| データ型 | 可変性 |
|---------|--------|
| リスト (list) | ミュータブル |
| 文字列 (str) | イミュータブル |
| タプル (tuple) | イミュータブル |
| 整数 (int) | イミュータブル |

リストは作成後も要素の追加・削除・変更が可能。一方、文字列・タプル・整数は一度作成すると内容を変更できない。

```python
# リストは変更可能
my_list = [1, 2, 3]
my_list[0] = 100  # OK

# 文字列は変更不可
my_str = "hello"
my_str[0] = "H"  # エラー発生
```

---

## 問2. インデクシング・スライシングができないデータ型

**問題：** 以下のうち、インデクシング・スライシングが**できない**データ型を選択せよ。

1. リスト
2. 文字列
3. タプル
4. 整数

**正解：4. 整数**

### 解説
インデクシングとスライシングは、シーケンス型（順序を持つデータ型）に対して使用できる操作である。

- **リスト・文字列・タプル**：シーケンス型なのでインデクシング・スライシングが可能
- **整数**：数値型であり、シーケンス型ではないため不可

```python
my_list = [1, 2, 3]
my_str = "hello"
my_tuple = (1, 2, 3)
my_int = 12345

print(my_list[0])   # 1
print(my_str[0])    # h
print(my_tuple[0])  # 1
print(my_int[0])    # TypeError: 'int' object is not subscriptable
```

---

## 問3. 剰余演算子の結果と解釈

**問題：** 以下のコードの結果と解釈として正しいものを選択せよ。

```python
x = 123456789
y = x % 3
print(y)
```

1. 出力は41152263であり、xが3の倍数であることを示している
2. 出力は41152263であり、xが3の倍数ではないことを示している
3. 出力は0であり、xが3の倍数であることを示している
4. 出力は0であり、xが3の倍数ではないことを示している

**正解：3. 出力は0であり、xが3の倍数であることを示している**

### 解説
`%` は剰余演算子で、割り算の余りを返す。

- `123456789 % 3 = 0`（余りが0）
- 余りが0ということは、123456789は3で割り切れる＝3の倍数である

確認：1+2+3+4+5+6+7+8+9 = 45（各桁の和が3の倍数なら、その数も3の倍数）

---

## 問4. 型変換関数

**問題：** 以下のコードの最後の出力を '12月' としたい場合に、□に入るコード(関数)として正しいものを選択せよ。

```python
month = 12
□(month) + '月'
```

1. len
2. int
3. str
4. tuple

**正解：3. str**

### 解説
文字列の連結（`+`）を行うには、両方が文字列型である必要がある。`month`は整数型なので、`str()`関数で文字列に変換する必要がある。

```python
month = 12
str(month) + '月'  # '12月'
```

- `len()`: 長さを返す関数
- `int()`: 整数に変換する関数
- `str()`: 文字列に変換する関数
- `tuple()`: タプルに変換する関数

---

## 問5. 変数の累積計算

**問題：** 以下のコードを上から実行した際の最後のaの値として正しいものを選択せよ。

```python
a = 10
i = 1
a = a + i
i = i + 1
a += i
a += a
a
```

1. 10
2. 11
3. 13
4. 26

**正解：4. 26**

### 解説
コードを1行ずつ追跡する：

| 行 | コード | a の値 | i の値 |
|----|--------|--------|--------|
| 1 | `a = 10` | 10 | - |
| 2 | `i = 1` | 10 | 1 |
| 3 | `a = a + i` | 11 (10+1) | 1 |
| 4 | `i = i + 1` | 11 | 2 |
| 5 | `a += i` | 13 (11+2) | 2 |
| 6 | `a += a` | 26 (13+13) | 2 |

最終的な `a` の値は **26**

---

## 問6. 文字列スライシング（誤っているもの）

**問題：** 以下のコードの最後の出力を 'PS' としたい場合に、□に入るコードとして**誤っているもの**を選択せよ。

```python
tool4 = 'Python and SQL'
□
tool4_abbr
```

1. `tool4_abbr = tool4[0] + tool4[11]`
2. `tool4_abbr = tool4[0:12][0] + tool4[0:12][-1]`
3. `tool4_abbr = tool4[0:11:11]`
4. `tool4_abbr = tool4[::-1][2::11][::-1]`

**正解：3. `tool4_abbr = tool4[0:11:11]`**

### 解説

#### 文字列のインデックス確認

まず、文字列の各文字とインデックスを確認する：

```
文字:    P   y   t   h   o   n       a   n   d       S   Q   L
正順:    0   1   2   3   4   5   6   7   8   9  10  11  12  13
逆順:  -14 -13 -12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1
```

目標は `'P'`（インデックス0）と `'S'`（インデックス11）を取り出して `'PS'` を作ること。

---

#### 選択肢1: `tool4_abbr = tool4[0] + tool4[11]`

**結果：`'PS'` ✓ 正しい**

最もシンプルな方法で、直接インデクシングを使用。

```python
tool4[0]   # → 'P'（先頭の文字）
tool4[11]  # → 'S'（12番目の文字）
'P' + 'S'  # → 'PS'
```

---

#### 選択肢2: `tool4_abbr = tool4[0:12][0] + tool4[0:12][-1]`

**結果：`'PS'` ✓ 正しい**

2段階でスライシングを行う方法。

**ステップ1：** `tool4[0:12]` を計算
```python
tool4[0:12]  # → 'Python and S'
```
インデックス0から11まで（12は含まない）の文字を取得。

**ステップ2：** その結果に対してインデクシング
```python
'Python and S'[0]   # → 'P'（先頭）
'Python and S'[-1]  # → 'S'（末尾）
```

**ステップ3：** 連結
```python
'P' + 'S'  # → 'PS'
```

---

#### 選択肢3: `tool4_abbr = tool4[0:11:11]`

**結果：`'P'` ✗ 誤り（これが正解）**

スライシングの構文 `[start:stop:step]` を使用。

```
[start:stop:step] の意味：
- start: 開始位置（この位置を含む）
- stop:  終了位置（この位置は含まない）← 重要！
- step:  何文字ごとに取得するか
```

この選択肢では：
- `start = 0`（開始位置）
- `stop = 11`（終了位置、この位置は**含まない**）
- `step = 11`（11文字ごとに取得）

**取得される文字の計算：**
```
開始: インデックス0 → 'P' ✓ 取得
次:   インデックス0+11=11 → 'S' だが...
      stop=11 なので、インデックス11は範囲外 ✗ 取得できない
```

```python
tool4[0:11:11]  # 結果: 'P' のみ
```

**修正するには：** `stop` を12以上にする必要がある
```python
tool4[0:12:11]  # 結果: 'PS'（インデックス0と11を取得）
```

---

#### 選択肢4: `tool4_abbr = tool4[::-1][2::11][::-1]`

**結果：`'PS'` ✓ 正しい**

3段階の操作を行う複雑な方法。

**ステップ1：** `tool4[::-1]` で文字列を反転
```python
'Python and SQL'[::-1]  # → 'LQS dna nohtyP'
```

反転後のインデックス：
```
文字:  L   Q   S       d   n   a       n   o   h   t   y   P
番号:  0   1   2   3   4   5   6   7   8   9  10  11  12  13
```

**ステップ2：** `[2::11]` でインデックス2から11ステップで取得
```python
'LQS dna nohtyP'[2::11]
```
取得される文字：
- インデックス2: `'S'` ✓
- インデックス2+11=13: `'P'` ✓

結果: `'SP'`

**ステップ3：** `[::-1]` で再度反転
```python
'SP'[::-1]  # → 'PS'
```

---

#### まとめ

| 選択肢 | コード | 結果 | 判定 |
|--------|--------|------|------|
| 1 | `tool4[0] + tool4[11]` | `'PS'` | ✓ 正しい |
| 2 | `tool4[0:12][0] + tool4[0:12][-1]` | `'PS'` | ✓ 正しい |
| 3 | `tool4[0:11:11]` | `'P'` | ✗ **誤り** |
| 4 | `tool4[::-1][2::11][::-1]` | `'PS'` | ✓ 正しい |

**ポイント：** スライシング `[start:stop:step]` において、`stop` の位置の要素は**含まれない**ことを理解しているかがこの問題の鍵。

---

## 問7. 文字列から部分文字列を抽出

**問題：** 次の文字列から"HelloWorld"を取り出して表示するのに正しいコードを選択せよ

```python
text = "SayHelloToTheWhoWorldToday"
```

1. `print(text[3:8] + text[-10:-5])`
2. `print(text[3:9] + text[-11:6])`
3. `print(text[4:9] + text[-10:-6])`
4. `print(text[4:10] + text[-11:-5])`

**正解：1. `print(text[3:8] + text[-10:-5])`**

### 解説

#### 文字列のインデックス確認

まず、文字列の各文字とインデックス（正順・逆順）を確認する：

```
文字:  S   a   y   H   e   l   l   o   T   o   T   h   e   W   h   o   W   o   r   l   d   T   o   d   a   y
正順:  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25
逆順:-26 -25 -24 -23 -22 -21 -20 -19 -18 -17 -16 -15 -14 -13 -12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1
```

抽出したい文字列：
- **"Hello"**: インデックス 3〜7（正順）、または -23〜-19（逆順）
- **"World"**: インデックス 16〜20（正順）、または -10〜-6（逆順）

---

#### 選択肢1: `print(text[3:8] + text[-10:-5])`

**結果：`'HelloWorld'` ✓ 正しい**

**"Hello" の抽出：** `text[3:8]`
```
インデックス 3, 4, 5, 6, 7 を取得（8は含まない）
  H   e   l   l   o
  3   4   5   6   7
→ 'Hello' ✓
```

**"World" の抽出：** `text[-10:-5]`
```
インデックス -10, -9, -8, -7, -6 を取得（-5は含まない）
  W   o   r   l   d
-10  -9  -8  -7  -6
→ 'World' ✓
```

**連結結果：** `'Hello' + 'World'` → `'HelloWorld'` ✓

---

#### 選択肢2: `print(text[3:9] + text[-11:6])`

**結果：`'HelloT' + ''` = `'HelloT'` ✗ 誤り**

**"Hello" の抽出：** `text[3:9]`
```
インデックス 3, 4, 5, 6, 7, 8 を取得
  H   e   l   l   o   T
  3   4   5   6   7   8
→ 'HelloT'（'T'が余分）✗
```

**"World" の抽出：** `text[-11:6]`
```
開始: -11（正順で15）
終了: 6
15 > 6 なので、開始位置が終了位置より後ろ → 空文字列 ''
```

**連結結果：** `'HelloT' + ''` → `'HelloT'` ✗

---

#### 選択肢3: `print(text[4:9] + text[-10:-6])`

**結果：`'elloT' + 'Worl'` = `'elloTWorl'` ✗ 誤り**

**"Hello" の抽出：** `text[4:9]`
```
インデックス 4, 5, 6, 7, 8 を取得
  e   l   l   o   T
  4   5   6   7   8
→ 'elloT'（'H'がない、'T'が余分）✗
```

**"World" の抽出：** `text[-10:-6]`
```
インデックス -10, -9, -8, -7 を取得（-6は含まない）
  W   o   r   l
-10  -9  -8  -7
→ 'Worl'（'d'がない）✗
```

**連結結果：** `'elloT' + 'Worl'` → `'elloTWorl'` ✗

---

#### 選択肢4: `print(text[4:10] + text[-11:-5])`

**結果：`'elloTo' + 'oWorld'` = `'elloTooWorld'` ✗ 誤り**

**"Hello" の抽出：** `text[4:10]`
```
インデックス 4, 5, 6, 7, 8, 9 を取得
  e   l   l   o   T   o
  4   5   6   7   8   9
→ 'elloTo'（'H'がない、'To'が余分）✗
```

**"World" の抽出：** `text[-11:-5]`
```
インデックス -11, -10, -9, -8, -7, -6 を取得（-5は含まない）
  o   W   o   r   l   d
-11 -10  -9  -8  -7  -6
→ 'oWorld'（先頭の'o'が余分）✗
```

**連結結果：** `'elloTo' + 'oWorld'` → `'elloTooWorld'` ✗

---

#### まとめ

| 選択肢 | コード | Hello部分 | World部分 | 結果 | 判定 |
|--------|--------|-----------|-----------|------|------|
| 1 | `text[3:8] + text[-10:-5]` | `'Hello'` | `'World'` | `'HelloWorld'` | ✓ **正解** |
| 2 | `text[3:9] + text[-11:6]` | `'HelloT'` | `''` | `'HelloT'` | ✗ |
| 3 | `text[4:9] + text[-10:-6]` | `'elloT'` | `'Worl'` | `'elloTWorl'` | ✗ |
| 4 | `text[4:10] + text[-11:-5]` | `'elloTo'` | `'oWorld'` | `'elloTooWorld'` | ✗ |

**ポイント：**
1. スライシング `[start:stop]` では、`stop` の位置は含まれない
2. 正順インデックスと逆順インデックスの対応を正確に把握する
3. 開始位置が終了位置より後ろの場合、空文字列が返る

---

## 問8. 黄金数の計算

**問題：** 黄金比における黄金数を求めるコードとして正しいものを選択せよ。

1. `(1 + 5) ** 0.5 / 2`
2. `(1 + 5 ** 1 / 2) / 2`
3. `1 + 5 ** 0.5 / 2`
4. `(1 + 5 ** 0.5) / 2`

**正解：4. `(1 + 5 ** 0.5) / 2`**

### 解説
黄金数（黄金比）φは以下の式で表される：

$$\phi = \frac{1 + \sqrt{5}}{2} \approx 1.618$$

Pythonでの計算：
- `5 ** 0.5` は √5（5の0.5乗 = 平方根）
- 演算子の優先順位：`**` > `/` > `+`

各選択肢の計算結果：

1. `(1 + 5) ** 0.5 / 2` = √6 / 2 ≈ 1.225
2. `(1 + 5 ** 1 / 2) / 2` = (1 + 2.5) / 2 = 1.75
3. `1 + 5 ** 0.5 / 2` = 1 + (√5 / 2) ≈ 2.118
4. `(1 + 5 ** 0.5) / 2` = (1 + √5) / 2 ≈ 1.618 ✓

---

## 問9. 偏差値の計算

**問題：** 以下のリスト scores は10人のテストの結果である。70点の人の偏差値を求めるコードの□に入るものとして正しいものを選択せよ。

```python
import statistics
scores = [51, 48, 83, 67, 48, 37, 59, 38, 56, 70]
mu = statistics.mean(scores)
sigma = statistics.stdev(scores)
□
```

1. `((70 - sigma) / mu)`
2. `((70 - mu) / sigma) * 10 + 50`
3. `(mu / sigma) * 70`
4. `((70 - mu) / sigma) * 50 + 10`

**正解：2. `((70 - mu) / sigma) * 10 + 50`**

### 解説
偏差値の公式：

$$偏差値 = \frac{(得点 - 平均点)}{標準偏差} \times 10 + 50$$

- `mu`：平均点（mean）
- `sigma`：標準偏差（standard deviation）
- 得点：70点

コードに当てはめると：
```python
((70 - mu) / sigma) * 10 + 50
```

偏差値は、平均点を50、標準偏差を10に換算した指標である。

---

## 問10. 調和平均の計算

**問題：** A地点からB地点まで100kmの道のりがある場合に、行きは時速 x km、帰りは時速 y kmで往復したときの調和平均を計算するコードとして正しいものを選択せよ。

1. `(x + y) / 2`
2. `(100 / x) + (100 / y)`
3. `2 / ((1 / x) + (1 / y))`
4. `(x * y) ** (1 / 2)`

**正解：3. `2 / ((1 / x) + (1 / y))`**

### 解説
調和平均（Harmonic Mean）は、速度の平均を求める際に使用される。

2つの値 x, y の調和平均：

$$H = \frac{2}{\frac{1}{x} + \frac{1}{y}} = \frac{2xy}{x + y}$$

各選択肢の意味：

1. `(x + y) / 2` → 算術平均（相加平均）
2. `(100 / x) + (100 / y)` → 往復にかかる合計時間
3. `2 / ((1 / x) + (1 / y))` → 調和平均 ✓
4. `(x * y) ** (1 / 2)` → 幾何平均（相乗平均）

往復の平均速度は、行きと帰りで距離が同じ場合、調和平均で求める。