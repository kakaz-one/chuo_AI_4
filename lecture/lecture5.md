# 第5回 NumPyによるベクトル・行列演算

*2025年10月20日 ver1.0.2*

---

## 目次

- NumPy とは
- 多次元配列の必要性
- 配列と要素型
- 配列要素の操作と演算
  - 整形
  - 要素の参照・代入
  - 基本的な演算
  - 統計関数・次元削減
  - 行列演算
  - ユニバーサル関数
  - ソート
- 乱数の生成
- （参考）画像の処理

---

## NumPy とは

### NumPy とは

NumPy は科学技術計算やデータ分析のためのライブラリである。

**Pythonで統計モデル・機械学習モデルを実装するうえで NumPy は必須！**

- **Numerical Python** の略
- NumPy では多次元配列を容易に扱うことができる
  - 多次元配列とはベクトルや行列のこと
  - 多次元配列オブジェクト ndarray を利用することで、大規模データを高速かつ柔軟に操作できる
- NumPy には数値計算のためのメソッド、関数が豊富に用意されている
  - NumPy でできることの例：
    - ベクトルや行列の演算
    - 複数の要素に対する数学関数の適用
    - 乱数の生成
- データ分析のための他のライブラリ（例：pandas、scikit-learn）の基盤になっている
  - 表形式のデータは pandas で処理することが多いが、NumPy の使い方を知っておくことは重要である

### ライブラリの読み込み

NumPy をインポートするには、以下のコードを実行する：

```python
import numpy as np
```

- NumPy はエイリアス（別名）を `np` でインポートすることが慣例となっている
- ※ `from numpy import *` のように入力して実行することもできるが、同じ名前の変数・関数を上書きしてしまうリスクがあるため非推奨

> 資料内のソースコードはNumPyがインポートされている前提で記載

---

## 多次元配列の必要性

### 多次元配列の必要性

データ分析を行う際には、大規模データを高速に処理することが要求される。

- データの収集が容易になり、データ分析の現場では数千万〜数億レコードを扱うこともある
  - さらに、一つのレコードが数十以上の属性・情報を持っていることもある
- 統計モデル・機械学習モデルを実装する際にも、多次元データの演算が要求されることがある
  - 例：ディープラーニングによる画像処理
- Python の組み込み型にも、リストやタプルのように配列を扱うデータ型は存在する
  - ただし、計算速度は速くない
- NumPy の ndarray は多次元配列を高速に計算できる

**多次元データの例（MNIST）**

- 機械学習のチュートリアルで使われることがある手書き文字のデータセット
- 28×28の784ピクセルの画像が70,000枚用意されている

### 多次元配列 (ndarray) の概要

配列には深さを表す次元があり、二次元以上の配列を多次元配列と呼ぶ。

**axis** とは配列の軸のことであり、一次元配列では軸は1つ、二次元配列では軸は2つある。

**一次元配列**

下図のように要素が横に一直線に並んでいる：

```python
array([6, 2, 3, 4, 1])
```

| [0] | [1] | [2] | [3] | [4] |
|-----|-----|-----|-----|-----|
| 6   | 2   | 3   | 4   | 1   |

→ axis 0

**二次元配列**

下図のように要素が縦横に一直線に並んでいる：

```python
array([[13, 4, 28, 16, 9],
       [30, 11, 5, 3, 21],
       [ 7, 14, 15, 34, 23]])
```

|        | [0]  | [1]  | [2]  | [3]  | [4]  |
|--------|------|------|------|------|------|
| **[0]** | 13   | 4    | 28   | 16   | 9    |
| **[1]** | 30   | 11   | 5    | 3    | 21   |
| **[2]** | 7    | 14   | 15   | 34   | 23   |

- 横方向 → axis 1
- 縦方向 → axis 0

### NumPy のメリット (1/2)

リストと ndarray の計算速度を比較すると、ndarray の方が速い場合が多い。

**要素数1億のリスト同士・ndarray 同士の計算時間を比較**

**リストを使う場合**

```python
%%time
a = list(range(0, 100000000, 1))
b = list(range(100000000, 0, -1))
c = list([0]*100000000)
for i in range(100000000):
    c[i] = a[i] + b[i]
```

実行結果：
```
Wall time: 18.2 s
```

→ 実行端末の性能等、環境で差はあるが、約18秒と処理に非常に長い時間がかかることが分かる

**ndarray を使う場合**

```python
%%time
a = np.arange(0, 100000000, 1)
b = np.arange(100000000, 0, -1)
c = a + b
```

実行結果：
```
Wall time: 5.44 s
```

→ 要素数1億の ndarray同士の計算時間は約5秒と、リストの計算時間より短くなることが分かる

### NumPy のメリット (2/2)

複数の要素に対する数学関数の適用を短いコードで書くことができる。

**numbers = list(range(10000)) の平方根を計算して新たなリスト（numbers_sqrt）に格納するコードの例**

**math モジュールを使う場合**

```python
%%time
numbers_sqrt = []
for i in numbers:
    numbers_sqrt.append(math.sqrt(i))
```

実行結果：
```
Wall time: 6.78 ms
```

**ndarray を使う場合**

```python
%%time
number_sqrt = list(np.sqrt(numbers))
```

実行結果：
```
Wall time: 2 ms
```

→ 計算時間が短いことに加え、コードの可読性も高くなる

---

## 配列と要素型

### 配列の作成に使用する関数

ndarray の作成には NumPy の関数を使用する。

代表的な関数の一覧：

| 関数 | 内容 | 使用例 | 実行結果 |
|------|------|--------|----------|
| `np.array()` | リストやタプルから配列を作成する | `np.array([0, 1, 2])` | `array([0, 1, 2])` |
| `np.arange()` | 範囲を指定して配列を作成する | `np.arange(3)` | `array([0, 1, 2])` |
| `np.zeros()` | すべての要素が 0 の配列を作成する | `np.zeros(3)` | `array([0., 0., 0.])` |
| `np.ones()` | すべての要素が 1 の配列を作成する | `np.ones(3)` | `array([1., 1., 1.])` |
| `np.identity()` | 単位行列を作成する | `np.identity(2)` | `array([[1., 0.], [0., 1.]])` |
| `np.eye()` | 単位行列を作成する | `np.eye(2)` | `array([[1., 0.], [0., 1.]])` |
| `np.empty()` | 値が初期化されていない配列を作成する | `np.empty(3)` | `array([0., 0., 1.])` |
| `np.linspace()` | 範囲内で等間隔の配列を作成する | `np.linspace(0, 1, 3)` | `array([0. , 0.5, 1. ])` |

### 配列の要素型の種類

基本的に ndarray 内のすべての要素は同じデータ型となる。

代表的なデータ型の一覧：

| 型 | 型コード | 説明 |
|----|----------|------|
| int8, uint8 | i1, u1 | 符号あり8ビット整数型 / 符号なし8ビット整数型 |
| int16, uint16 | i2, u2 | 符号あり16ビット整数型 / 符号なし16ビット整数型 |
| int32, uint32 | i3, u3 | 符号あり32ビット整数型 / 符号なし32ビット整数型 |
| int64, uint64 | i4, u4 | 符号あり64ビット整数型 / 符号なし64ビット整数型 |
| float16 | f2 | 半精度浮動小数点型 |
| float32 | f4 (f) | 単精度浮動小数点型 |
| float64 | f8 (d) | 倍精度浮動小数点型 |
| float128 | f16 (g) | 四倍精度浮動小数点型 |
| complex64 | c8 | 複素数型（実部・虚部ともに32ビット単精度型） |
| complex128 | c16 | 複素数型（実部・虚部ともに64ビット単精度型） |
| complex256 | c32 | 複素数型（実部・虚部ともに128ビット単精度型） |
| bool | ? | ブール（真偽値）型 |
| unicode | U | 固定長Unicode文字列型 |
| object | S | Pythonオブジェクト型 |

### 配列の作成

ndarray は `array()` 関数を使ってリストまたはタプルから作成できる。

**使用例**

```python
arr1 = np.array([1, 2, 3])
arr2 = np.array([(1, 2, 3), (4, 5, 6)])
arr1  # ①
arr2  # ②
```

**実行結果**

```python
① array([1, 2, 3])
② array([[1, 2, 3],
         [4, 5, 6]])
```

### 配列の要素型 (1/2)

基本的に ndarray 内のすべての要素は同じデータ型となる。

- 配列のデータ型は使用したシーケンスの要素から決定される
- `array()` 関数で配列を作成する際、引数の `dtype` でデータ型を指定することができる
- ndarray の要素のデータ型は、`dtype` 属性で取得できる
  - オブジェクトはデータ型ごとに属性（アトリビュート、attribute）を持っており、オブジェクトにドット ( . ) を付けて属性名を記述する

**使用例**

```python
arr1 = np.array([0, 1, 2, 3, 4])
arr1.dtype  # ①

arr2 = np.array([0, 1, 2, 3, 4], dtype=float)
arr2.dtype  # ②

arr3 = np.array([0.1, 0.7, 0.3, 0.5])
arr3.dtype  # ③
```

**実行結果**

```python
① dtype('int64')
② dtype('float64')
③ dtype('float64')
```

### 配列の要素型 (2/2)

`astype()` メソッドで、ndarray の要素のデータ型を変更（キャスト）できる。

**使用例**

`astype(float)` で、ndarray を int型 から float型 に変更する：

```python
arr1 = np.array([0, 1, 2, 3, 4])
arr1.dtype  # ①

arr2 = arr1.astype(float)
arr2.dtype  # ②
```

**実行結果**

```python
① dtype('int64')
② dtype('float64')
```

### 複素数配列の作成

複素数配列を作成する場合は、`dtype` に `complex` を指定する。

- 数学では一般的に虚数単位に `i` が使われるが、Python では `j` が使われる

**使用例**

```python
arr = np.array([[1, 2], [3, 4]], dtype=complex)
arr        # ①
arr.dtype  # ②
```

**実行結果**

```python
① array([[1.+0.j, 2.+0.j],
         [3.+0.j, 4.+0.j]])
② dtype('complex128')
```

### 配列の確認

ndarray の次元数、全要素数、形状 (各次元のサイズ) は、それぞれ `ndim` 属性、`size` 属性、`shape` 属性で取得できる。

**使用例**

```python
arr1 = np.array([0, 1, 2, 3, 4])
arr1.ndim   # ①
arr1.size   # ②
arr1.shape  # ③

arr2 = np.array([[0, 1, 2], [3, 4, 5]])
arr2.ndim   # ④
arr2.size   # ⑤
arr2.shape  # ⑥
```

**実行結果**

```python
① 1
② 5
③ (5,)
④ 2
⑤ 6
⑥ (2, 3)
```

### 等差数列の作成

`arange()` 関数を使うと、範囲を指定して配列（等差数列）を生成できる。

**arange() 関数の使い方**

```python
np.arange([start,] stop[, step][, dtype])
```

- `start`：(省略可能、初期値 0) 生成する等差数列の最初の項を指定する
- `stop`：生成する等差数列の終点を指定する
- `step`：(省略可能、初期値 1) 生成される数列の公差を指定する ※
- `dtype`：(省略可能、初期値 None) 生成される数列のデータ型を指定する

※ Python の組み込み関数である `range()` と異なり、`step` に小数を指定することができる

**使用例**

```python
np.arange(5)        # ①
np.arange(2, 5)     # ②
np.arange(1, 10, 2) # ③
```

- `np.arange()` に数値を一つ渡すと、0 から stop-1 までの値が格納された配列が生成される (①)

**実行結果**

```python
① array([0, 1, 2, 3, 4])
② array([2, 3, 4])
③ array([1, 3, 5, 7, 9])
```

### 要素がすべて0の配列の作成

配列の全要素を 0 で初期化した配列を作成するには、`zeros()` 関数を使用する。

**zeros() 関数の使い方**

```python
np.zeros(shape[, dtype][, order])
```

- `shape`：生成する配列の shape を int または int のタプルで指定する
- `dtype`：(省略可能、初期値 float64) 生成する配列の要素のデータ型を指定する
- `order`：(省略可能、初期値 'C') 配列のデータの保存の仕方を指定する (あまり使用することはない)

**使用例**

```python
np.zeros(3)                   # ①
np.zeros((2, 3), dtype=int)   # ②
```

**実行結果**

```python
① array([0., 0., 0.])
② array([[0, 0, 0],
         [0, 0, 0]])
```

### 要素がすべて1の配列の作成

配列の全要素を 1 で初期化した配列を作成するには、`ones()` 関数を使用する。

**ones() 関数の使い方**

```python
np.ones(shape[, dtype][, order])
```

- `shape`：生成する配列の shape を int または int のタプルで指定する
- `dtype`：(省略可能、初期値 float64) 生成する配列の要素のデータ型を指定する
- `order`：(省略可能、初期値 'C') 配列のデータの保存の仕方を指定する (あまり使用することはない)

**使用例**

```python
np.ones(3)                    # ①
np.ones((2, 3), dtype=np.int) # ②
```

**実行結果**

```python
① array([1., 1., 1.])
② array([[1, 1, 1],
         [1, 1, 1]])
```

### 単位行列の作成 (1/3)

単位行列を作成する関数の一つとして `identity()` 関数がある。

**identity() 関数の使い方**

```python
np.identity(n[, dtype])
```

- `n`：生成する行列のサイズを指定する
- `dtype`：(省略可能、初期値 float64) 生成する配列の要素のデータ型を指定する

**使用例**

`identity()` 関数は行数、列数が一致した正方行列のみ生成できる：

```python
np.identity(2)               # ①
np.identity(2, dtype=np.int) # ②
```

**実行結果**

```python
① array([[1., 0.],
         [0., 1.]])
② array([[1, 0],
         [0, 1]])
```

### 単位行列の作成 (2/3)

単位行列を作成する関数の一つとして `eye()` 関数がある。

**eye() 関数の使い方**

```python
np.eye(N[, M][, k][, dtype])
```

- `N`：生成する単位行列の行数を指定する
- `M`：(省略可能、初期値 None) 生成される単位行列の列数を指定する (Noneの時はNと同じ値になる)
- `k`：(省略可能、初期値 0) 1を要素とする対角線がどの位置になるかを指定する
- `dtype`：(省略可能、初期値 float64) 生成する配列の要素のデータ型を指定する

**使用例**

```python
np.eye(3, dtype=int)    # ① 列数を省略して3×3の単位行列を生成
np.eye(3, 5, dtype=int) # ② 3×5の単位行列を生成
```

**実行結果**

```python
① array([[1, 0, 0],
         [0, 1, 0],
         [0, 0, 1]])
② array([[1, 0, 0, 0, 0],
         [0, 1, 0, 0, 0],
         [0, 0, 1, 0, 0]])
```

### 単位行列の作成 (3/3)

`eye()` 関数の引数 `k` により、要素1が並ぶ対角線の位置を指定できる。

- 特別な指定のない単位行列を作成する場合は `identity()` 関数を使用し、特殊な単位行列を作成する場合は `eye()` 関数を使用する

**使用例**

```python
np.eye(4, k=1, dtype=np.int)  # ① 上方に1つ移動
np.eye(4, k=-2, dtype=np.int) # ② 下方に2つ移動
```

**実行結果**

```python
① array([[0, 1, 0, 0],
         [0, 0, 1, 0],
         [0, 0, 0, 1],
         [0, 0, 0, 0]])
② array([[0, 0, 0, 0],
         [0, 0, 0, 0],
         [1, 0, 0, 0],
         [0, 1, 0, 0]])
```

### 練習問題

以下の配列を作成せよ。また、配列のデータ型、次元数、要素数、形状（各次元のサイズ）を確認せよ。

```python
array([[0, 2, 4],
       [1, 3, 5]])
```

---

## 配列要素の操作と演算

### 整形

#### 軸数（次元数）の変更 (1/4)

`reshape()` メソッドを使用すると、ndarray の形状を変形できる。

- 第一引数に変換後の形状をリストやタプルで指定する
- 元の配列と指定した変換後の配列の要素数が一致しなければエラーとなる

**使用例**

```python
arr1 = np.arange(24)
arr1.reshape([4, 6])  # ① 4×6 (行数4、列数6) の二次元配列に変換
arr1.reshape([2, 6])  # ②
```

**実行結果**

```python
① array([[ 0,  1,  2,  3,  4,  5],
         [ 6,  7,  8,  9, 10, 11],
         [12, 13, 14, 15, 16, 17],
         [18, 19, 20, 21, 22, 23]])
② ValueError: cannot reshape array of size 24 into shape (2,6)
```

#### 軸数（次元数）の変更 (2/4)

`reshape()` メソッドでは値として -1 を指定することができる。

- -1 とした次元の長さは、他の次元の指定値から自動的に決定される
- -1 を指定した際に、条件を満たす値が存在しなければエラーになる

**使用例**

```python
arr1 = np.arange(12)
arr1.reshape([3, -1])  # ① 3行4列に変形
arr1.reshape([-1, 6])  # ② 2行6列に変形
arr1.reshape([8, -1])  # ③
```

**実行結果**

```python
① array([[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]])
② array([[ 0,  1,  2,  3,  4,  5],
         [ 6,  7,  8,  9, 10, 11]])
③ ValueError: cannot reshape array of size 12 into shape (8,newaxis)
   # 要素数12に対して行数を8に指定しており、適当な列数が存在しないためエラーとなる
```

#### 軸数（次元数）の変更 (3/4)

`resize()` メソッドでも ndarray の形状を変形することができる。

- `resize()` メソッドは変形前後で配列の要素数が異なっていてもエラーにならない
  - 変形された配列が元の配列より大きい場合、必要なだけ 0 で埋められる
  - 変形された配列が元の配列より小さい場合、余った要素は捨てられる

**使用例**

```python
arr1 = np.arange(12)
arr1.resize([3, 4]); arr1  # ①

arr1 = np.arange(12)
arr1.resize([2, 8]); arr1  # ②

arr1 = np.arange(12)
arr1.resize([2, 4]); arr1  # ③
```

**実行結果**

```python
① array([[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]])
② array([[ 0,  1,  2,  3,  4,  5,  6,  7],
         [ 8,  9, 10, 11,  0,  0,  0,  0]])
③ array([[0, 1, 2, 3],
         [4, 5, 6, 7]])
```

#### 軸数（次元数）の変更 (4/4)

`resize()` メソッドは `reshape()` メソッドと違い、元の配列に直接変更を加える。

- 一般的に、`resize()` メソッドのようにオブジェクトの中身を直接変更するメソッドを**破壊的メソッド**といい、`reshape()` メソッドのように、オブジェクトの中身を直接変更しないメソッドを**非破壊的メソッド**という
- `reshape()` メソッドによる変更を維持するには任意の変数に格納する必要がある

**使用例**

```python
a, b = np.arange(12), np.arange(12)
a.resize([3, 4])
b.reshape([3, 4])
a  # ①
b  # ②
```

**実行結果**

```python
① array([[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]])
② array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
```

#### 転置（行と列の入れ替え）

ndarray の転置行列は、`T` 属性または `transpose()` 関数で取得できる。

**使用例**

```python
arr1 = np.arange(6).reshape([2, 3])
# array([[0, 1, 2],
#        [3, 4, 5]])

arr1.T             # ①
np.transpose(arr1) # ②
```

**実行結果**

```python
① array([[ 0,  1],
         [ 2,  3],
         [ 4,  5]])
② array([[ 0,  1],
         [ 2,  3],
         [ 4,  5]])
```

#### 一次元配列化 (1/2)

`flatten()` メソッド、`ravel()` メソッド、`reshape()` メソッドを使用すると、多次元配列を一次元配列へと変換できる。

**使用例**

```python
arr1 = np.array([[3, 4, 7], [4, 1, 10], [9, 8, 2]])
# array([[3, 4, 7],
#        [4, 1, 10],
#        [9, 8, 2]])

arr1.flatten()   # ①
arr1.ravel()     # ②
arr1.reshape(-1) # ③
```

**実行結果**

```python
① array([3, 4, 7, 4, 1, 10, 9, 8, 2])
② array([3, 4, 7, 4, 1, 10, 9, 8, 2])
③ array([3, 4, 7, 4, 1, 10, 9, 8, 2])
```

#### 一次元配列化 (2/2)

`ravel()` メソッドと `reshape()` メソッドは基本的に参照を返すのに対し、`flatten()` メソッドは常にコピーを返す。

- `ravel()` メソッドと `reshape()` メソッドは基本的に参照を返すため、一方の値を変更すると他方の値も変更される
- `flatten()` メソッドは常にコピーを返すため、一方の値を変更しても他方の値は変更されない

**使用例**

```python
arr1_r = np.array([[3, 4, 7], [4, 1, 10], [9, 8, 2]])
arr2_r = arr1_r.ravel()
arr2_r[0] = 100
arr1_r[0, 0]  # ①

arr1_f = np.array([[3, 4, 7], [4, 1, 10], [9, 8, 2]])
arr2_f = arr1_f.flatten()
arr2_f[0] = 100
arr1_f[0, 0]  # ②
```

**実行結果**

```python
① np.int64(100)
② np.int64(3)
```

### 要素の参照・代入

ndarray もリストと同様に、インデクシングやスライシングにより要素の参照・代入を行うことができる。

#### 一次元配列における要素の参照

**使用例**

```python
a = np.array([0, 1, 2, 3, 4])
a[1]    # ①
a[1:4]  # ② a[4]は入らないことに注意
a[::-1] # ③
```

**実行結果**

```python
① np.int64(1)
② array([1, 2, 3])
③ array([4, 3, 2, 1, 0])
```

#### 二次元配列における要素の参照 (1/2)

- 二次元以上の場合、リストと異なり各次元の添字をカンマ区切りで指定できる

**使用例**

```python
a = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
a[0][2] # ①
a[0, 2] # ②
a[2, 2] # ③
a[1]    # ④
a[-1]   # ⑤
```

**実行結果**

```python
① np.int64(2)
② np.int64(2)
③ np.int64(8)
④ array([3, 4, 5])
⑤ array([6, 7, 8])
```

#### 二次元配列における要素の参照 (2/2)

**使用例**

```python
a = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
a[1:2]      # ①
a[0:3, 1]   # ②
a[:, 2]     # ③
a[1:3, :]   # ④
a[1:3, ...] # ⑤  「…」は「 : 」と同等である
```

**実行結果**

```python
① array([3, 4, 5])
② array([1, 4, 7])
③ array([2, 5, 8])
④ array([[3, 4, 5],
         [6, 7, 8]])
⑤ array([[3, 4, 5],
         [6, 7, 8]])
```

#### 要素の代入

**使用例**

```python
a = np.arange(10)
# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

a[1] = 10
a            # ①

a[3:8:2] = 100
a            # ②

b = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
b[:2, 1:] = 0
b            # ③
```

**実行結果**

```python
① array([ 0, 10,  2,  3,  4,  5,  6,  7,  8,  9])
② array([  0,  10,   2, 100,   4, 100,   6, 100,   8,   9])
③ array([[0, 0, 0],
         [3, 0, 0],
         [6, 7, 8]])
```

#### 練習問題

以下のような配列を作成せよ。

```python
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]])
```

### 基本的な演算

#### 一次元配列における演算

同じサイズの配列、および配列とスカラーの演算を行うことができる。

**使用例**

```python
a = np.array([20, 30, 40, 50])
b = np.arange(4)

a + b   # ① 加算
a - b   # ② 減算
b * 2   # ③ 定数倍
b ** 2  # ④ 累乗
a < 35  # ⑤ 比較
```

**実行結果**

```python
① array([20, 31, 42, 53])
② array([20, 29, 38, 47])
③ array([0, 2, 4, 6])
④ array([0, 1, 4, 9])
⑤ array([ True,  True, False, False])
```

#### 二次元配列における演算（要素積）

二次元配列同士の要素積は `*` 演算子で求めることができる。

- 要素積を求める場合、2つの配列が同じサイズでなければならない

**使用例**

```python
A = np.array([[1, 1], [0, 1]])
B = np.array([[2, 0], [3, 4]])
A * B
```

計算：
```
[[1, 1],    [[2, 0],      [[1 * 2, 1 * 0],
 [0, 1]]  ×  [3, 4]]  →    [0 * 3, 1 * 4]]
```

**実行結果**

```python
array([[2, 0],
       [0, 4]])
```

**サイズが一致しておらずエラーになる例**

```python
A = np.array([[1, 1], [0, 1], [1, 1]])  # 行数3、列数2の配列
B = np.array([[2, 0], [3, 4]])          # 行数2、列数2の配列
A * B
# ValueError: operands could not be broadcast together with shapes (3,2) (2,2)
```

### 統計関数・次元削減

#### 統計関数

配列の全要素、または指定した軸に対して統計処理を行うことができる。

代表的な統計関数の一覧：

| 関数 | メソッド | 内容 | 使用例 | 実行結果 |
|------|----------|------|--------|----------|
| `np.sum()` | `.sum()` | 合計を返す | `a = np.array([1, 2, 3, 4])`<br>`np.sum(a)` | `np.int64(10)` |
| `np.mean()` | `.mean()` | 算術平均を返す | `np.mean(a)` | `np.float64(2.5)` |
| `np.std()` | `.std()` | 標準偏差を返す | `np.std(a)` | `np.float64(1.118...)` |
| `np.var()` | `.var()` | 分散を返す | `np.var(a)` | `np.float64(1.25)` |
| `np.max()` | `.max()` | 最大値を返す | `np.max(a)` | `np.int64(4)` |
| `np.min()` | `.min()` | 最小値を返す | `np.min(a)` | `np.int64(1)` |
| `np.cumsum()` | `.cumsum()` | 累積和を返す | `np.cumsum(a)` | `array([ 1, 3, 6, 10])` |
| `np.cumprod()` | `.cumprod()` | 累積積を返す | `np.cumprod(a)` | `array([ 1, 2, 6, 24])` |

#### 多次元配列での適用

統計関数は多次元配列にも適用することができる。

**使用例**

```python
a = np.arange(12).reshape(3, 4)
# [[ 0,  1,  2,  3],
#  [ 4,  5,  6,  7],
#  [ 8,  9, 10, 11]]

a.sum()     # ①
a.mean()    # ②
a.std()     # ③
a.max()     # ④
a.min()     # ⑤
a.cumsum()  # ⑥ 計算の過程も含めた結果を返す
```

**実行結果**

```python
① np.int64(66)
② np.float64(5.5)
③ np.float64(3.452052529534663)
④ np.int64(11)
⑤ np.int64(0)
⑥ array([ 0,  1,  3,  6, 10, 15, 21, 28, 36, 45, 55, 66])
```

#### 軸ごとの関数の適用 (1/2)

関数・メソッドの引数 `axis` で、関数を適用する軸を指定することができる。

**使用例（axis=0：縦方向）**

```python
a = np.arange(12).reshape(3, 4)
# [[ 0,  1,  2,  3],
#  [ 4,  5,  6,  7],
#  [ 8,  9, 10, 11]]

a.sum(axis=0)     # ①
a.mean(axis=0)    # ②
a.std(axis=0)     # ③
a.max(axis=0)     # ④
a.min(axis=0)     # ⑤
a.cumsum(axis=0)  # ⑥
```

**実行結果**

```python
① array([12, 15, 18, 21])
② array([4., 5., 6., 7.])
③ array([3.26598632, 3.26598632, 3.26598632, 3.26598632])
④ array([ 8,  9, 10, 11])
⑤ array([0, 1, 2, 3])
⑥ array([[ 0,  1,  2,  3],
         [ 4,  6,  8, 10],
         [12, 15, 18, 21]])
```

#### 軸ごとの関数の適用 (2/2)

**使用例（axis=1：横方向）**

```python
a = np.arange(12).reshape(3, 4)

a.sum(axis=1)     # ①
a.mean(axis=1)    # ②
a.std(axis=1)     # ③
a.max(axis=1)     # ④
a.min(axis=1)     # ⑤
a.cumsum(axis=1)  # ⑥
```

**実行結果**

```python
① array([ 6, 22, 38])
② array([1.5, 5.5, 9.5])
③ array([1.11803399, 1.11803399, 1.11803399])
④ array([ 3,  7, 11])
⑤ array([0, 4, 8])
⑥ array([[ 0,  1,  3,  6],
         [ 4,  9, 15, 22],
         [ 8, 17, 27, 38]])
```

### 行列演算

#### 行列演算のための関数

NumPy には行列演算のための関数が用意されている。

代表的な行列演算の関数の一覧：

| 関数 | 内容 | 使用例 | 実行結果 |
|------|------|--------|----------|
| `np.dot()` | 2つのベクトルの内積、2つの行列の積を返す | `arr1 = np.array([[1, 1], [0, 1]])`<br>`arr2 = np.array([[2, 0], [3, 4]])`<br>`np.dot(arr1, arr2)` | `array([[5, 4], [3, 4]])` |
| `np.diag()` | 正方行列の対角成分を返す | `arr = np.arange(9).reshape(3, 3)`<br>`np.diag(arr)` | `array([0, 4, 8])` |
| `np.linalg.inv()` | 正方行列の逆行列を返す | `arr = np.arange(4).reshape(2, 2)`<br>`np.linalg.inv(arr)` | `array([[-1.5, 0.5], [ 1., 0.]])` |
| `np.linalg.eig()` | 正方行列の固有値および固有ベクトルを返す | `np.linalg.eig(arr)` | EigResult |
| `np.linalg.svd()` | 特異値分解を行う | `np.linalg.svd(arr)` | SVDResult |

#### 二次元配列における行列の積

二次元配列の行列の積は `dot()` 関数で求めることができる。

- `dot()` メソッドを使っても求めることができる
- 行列積を求める場合は arr1 の列数と arr2 の行数が同じでなければならない

**使用例**

```python
arr1 = np.array([[1, 1], [0, 1]])
arr2 = np.array([[2, 0], [3, 4]])

np.dot(arr1, arr2) # ①
arr1.dot(arr2)     # ②
```

計算：
```
[[1, 1],    [[2, 0],      [[1*2 + 1*3, 1*0 + 1*4],
 [0, 1]]  ×  [3, 4]]  =    [0*2 + 1*3, 0*0 + 1*4]]
```

**実行結果**

```python
① array([[5, 4],
         [3, 4]])
② array([[5, 4],
         [3, 4]])
```

#### 正方行列の対角成分の取得

正方行列の対角成分は `diag()` 関数で求めることができる。

- 引数 `k` を指定すると開始位置を変更することができる
- 引数に一次元配列を指定すると、指定した配列を対角成分にした行列を作成することができる

**使用例**

```python
arr1 = np.arange(9).reshape(3, 3)
# array([[0, 1, 2],
#        [3, 4, 5],
#        [6, 7, 8]])

np.diag(arr1)       # ①
np.diag(arr1, k=1)  # ②
np.diag([0, 4, 8])  # ③
```

**実行結果**

```python
① array([0, 4, 8])
② array([1, 5])
③ array([[0, 0, 0],
         [0, 4, 0],
         [0, 0, 8]])
```

`diagonal()` メソッドを使っても対角成分を取得できる（開始位置を変更する引数は `k` ではなく `offset` になる）：

```python
arr1.diagonal(offset=1)
# array([1])
```

### ユニバーサル関数

ユニバーサル関数※ を使うと、すべての配列の要素に対して関数を適用できる。

※ universal function や ufunc と表記されることもある

代表的なユニバーサル関数の一覧：

| 関数 | 内容 | 使用例 | 実行結果 |
|------|------|--------|----------|
| `np.abs()` | 各要素の絶対値を返す | `np.abs(np.array([-1, 0, 1]))` | `array([1, 0, 1])` |
| `np.sqrt()` | 各要素の平方根を返す | `np.sqrt(np.arange(1, 5))` | `array([1., 1.414..., 1.732..., 2.])` |
| `np.square()` | 各要素の自乗（2乗）を返す | `np.square(np.arange(1, 5))` | `array([1, 4, 9, 16])` |
| `np.exp()` | 各要素の自然対数の底e のべき乗を返す（e^x） | `np.exp(np.arange(3))` | `array([1., 2.718..., 7.389...])` |
| `np.log()` | 各要素の e を底とする自然対数を返す | `np.log(np.arange(1, 5))` | `array([0., 0.693..., 1.098..., 1.386...])` |
| `np.sin()` | 各要素の正弦を返す（引数はラジアン） | `np.sin(np.array([0, math.pi/2]))` | `array([0., 1.])` |
| `np.cos()` | 各要素の余弦を返す（引数はラジアン） | `np.cos(np.array([0, math.pi]))` | `array([ 1., -1.])` |
| `np.tan()` | 各要素の正接を返す（引数はラジアン） | `np.tan(np.array([0, np.deg2rad(60)]))` | `array([ 0., 1.732...])` |
| `np.ceil()` | 各要素の小数を切り上げた値を返す | `np.ceil(np.arange(1, 3, 0.5))` | `array([1, 2, 2, 3])` |
| `np.floor()` | 各要素の小数を切り捨てた値を返す | `np.floor(np.arange(1, 3, 0.5))` | `array([1, 1, 2, 2])` |

#### 多次元配列での適用

ユニバーサル関数は多次元配列にも適用することができる。

**使用例**

```python
a = np.arange(12).reshape(3, 4)
# [[ 0,  1,  2,  3],
#  [ 4,  5,  6,  7],
#  [ 8,  9, 10, 11]]

np.abs(a)    # ①
np.sqrt(a)   # ②
np.square(a) # ③
```

**実行結果**

```python
① array([[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]])
② array([[0.        , 1.        , 1.41421356, 1.73205081],
         [2.        , 2.23606798, 2.44948974, 2.64575131],
         [2.82842712, 3.        , 3.16227766, 3.31662479]])
③ array([[  0,   1,   4,   9],
         [ 16,  25,  36,  49],
         [ 64,  81, 100, 121]])
```

### ソート

#### 要素のソート (1/2)

ndarray をソートしたい場合は NumPy の `sort()` 関数を使用する。

- `sort()` 関数はデフォルトでは昇順でソートする
- NumPy の `sort()` 関数には、Python標準の `sorted()` 関数のように引数 `reverse` は存在しないのでスライス `[::-1]` で取得する
- `sort()` 関数は元の ndarray はそのままで、ソートされた新しい ndarray を返す

**使用例**

```python
arr = np.array([1, 4, 5, 3, 2])
np.sort(arr)        # ①
np.sort(arr)[::-1]  # ②
```

**実行結果**

```python
① array([1, 2, 3, 4, 5])
② array([5, 4, 3, 2, 1])
```

**（参考）組み込みの sorted 関数を利用すると、戻り値がリストになる**

```python
sorted(arr)                 # ① [np.int64(1), np.int64(2), np.int64(3), np.int64(4), np.int64(5)]
sorted(arr, reverse=True)   # ② [np.int64(5), np.int64(4), np.int64(3), np.int64(2), np.int64(1)]
```

#### 要素のソート (2/2)

二次元配列をソートしたい場合は `sort()` 関数の引数 `axis` を指定し、行または列ごとにソートする。

**使用例**

```python
a = np.array([[1, 3, 4, 2], [2, 4, 1, 3]])
np.sort(a, axis=0)  # ①
np.sort(a, axis=1)  # ②
```

**実行結果**

```python
① array([[1, 3, 1, 2],
         [2, 4, 4, 3]])
② array([[1, 2, 3, 4],
         [1, 2, 3, 4]])
```

#### ソート前のインデックスの取得 (1/2)

ソートした配列ではなく、ソートした時のソート前のインデックスを取得する場合は `argsort()` 関数を使用する。

- ソートした時の元の配列のインデックスを保持した配列を返す

**使用例**

```python
arr = np.array([1, 4, 3, 3, 2])
np.argsort(arr)
```

**処理の流れ**

```
[0]  [1]  [2]  [3]  [4]
 1    4    3    3    2
        ↓ ソート
[0]  [4]  [2]  [3]  [1]
 1    2    3    3    4
        ↓ インデックスを返す
array([0, 4, 2, 3, 1])
```

**実行結果**

```python
array([0, 4, 2, 3, 1])
```

#### ソート前のインデックスの取得 (2/2)

**使用例**

```python
arr = np.array([[1, 3, 4, 2], [2, 4, 1, 3]])
np.argsort(arr, axis=0)  # ①
np.argsort(arr, axis=1)  # ②
```

**実行結果**

```python
① array([[0, 0, 1, 0],
         [1, 1, 0, 1]])
② array([[0, 3, 1, 2],
         [2, 0, 3, 1]])
```

#### 練習問題

以下の条件を満たす関数を定義せよ。

- 入力された配列の行ごとの平均、列ごとの平均、対角成分を出力する
- 正方行列以外が入力された場合、「行と列の数が異なっています」と出力し、合計や対角成分は出力しない
- 関数名は `array_mean_and_diag`
- 戻り値はなし

**関数の使用例**

```python
arr1 = np.arange(4).reshape(2, 2)
array_mean_and_diag(arr1)
```

**実行結果**

```
行の平均: [0.5 2.5]
列の平均: [1. 2.]
対角成分: [0 3]
```

> ヒント：組み込み関数の `print()` 関数を使うと、`np.array([1, 2])` は `[1 2]` と出力される

---

## 乱数の生成

### 乱数の生成 (1/3)

研究や業務において、乱数が必要になることがある。

Python の標準ライブラリの `random` モジュールを使用すると乱数を生成することができる。

> 実行する環境によって実行結果の数値は異なる

**使用例**

```python
import random
random.random()
# 0.9004789666079244
```

標準ライブラリの random モジュールでは、複数の乱数を生成する場合、for文を使う必要がある：

```python
random_list = []
for i in range(3):
    random_list.append(random.random())
random_list
# [0.9744708171852539, 0.12681681674774958, 0.7578991118618683]
```

### 乱数の生成 (2/3)

NumPy の random モジュールを使うと、for文を使わずに複数の乱数を生成することができる。

- 多次元の配列を作成することもできる

> 実行する環境によって実行結果の数値は異なる

**使用例**

```python
np.random.rand()       # ① 0.7001220508861707
np.random.rand(3)      # ② array([0.05474645, 0.61700722, 0.11233104])
np.random.rand(2, 3)   # ③ array([[0.46248801, 0.73487037, 0.3360822 ],
                       #          [0.54613582, 0.95258113, 0.11415461]])
```

### 乱数の生成 (3/3)

特定の確率分布に従う乱数を発生させることもできる。

代表的な乱数生成の関数の一覧：

| 関数 | 内容 |
|------|------|
| `np.random.rand()` | 連続一様分布に従う乱数を返す（0以上1未満） |
| `np.random.randint()` | 指定した範囲内の整数乱数を返す |
| `np.random.randn()` | 標準正規分布に従う乱数を返す |
| `np.random.normal()` | 正規分布に従う乱数を返す |
| `np.random.binomial()` | 二項分布に従う乱数を返す |
| `np.random.beta()` | ベータ分布に従う乱数を返す |
| `np.random.gamma()` | ガンマ分布に従う乱数を返す |
| `np.random.chisquare()` | カイ二乗分布に従う乱数を返す |
| `np.random.poisson()` | ポアソン分布に従う乱数を返す |

### seed の固定

乱数の seed を固定すると、同じ順序で同じ乱数を取得することができる。

- 分析や研究における再現性の担保において重要である
- NumPy における乱数は正確には擬似乱数であり、特定のアルゴリズムに従って数値が取得される

**使用例**

```python
np.random.seed(42)     # 42以外の数字でもよい
np.random.rand(3)      # ① array([0.37454012, 0.95071431, 0.73199394])
np.random.rand(3)      # ② array([0.59865848, 0.15601864, 0.15599452])

# (ランタイムを再起動)
np.random.seed(42)
np.random.rand(3)      # ③ array([0.37454012, 0.95071431, 0.73199394])
np.random.rand(3)      # ④ array([0.59865848, 0.15601864, 0.15599452])
```

①と③、②と④は同じ結果になる。

### 章末課題

5人の得点のそれぞれの偏差値を求める際、□に入るコードとして誤っている番号を選択せよ。

```python
score = np.array([59, 63, 47, 42, 80])
50 + □
```

**出力結果**

```python
array([50.60070625, 53.60423747, 41.59011257, 37.83569854, 66.36924518])
```

標準偏差は `50 + 10 * ((得点 - 得点の平均) / 得点の標準偏差)` で求めることができる

**選択肢**

1. `10 * ((score - np.mean(score)) / np.std(score))`
2. `10 * ((score - score.mean()) / score.std())`
3. `10 * ((score - np.mean(score)) / np.sqrt(np.var(score)))`
4. `10 * ((score - score.sum() / score.ndim) / np.sqrt(np.var(score)))`

> 動画を見て回答してください

---

## （参考）画像の処理

### 画像の読み込み (1/2)

NumPy と画像処理ライブラリの Pillow を使うと画像を読み込むことができる。

- Google Drive に任意の画像をアップロードし、Google Drive をマウントしておく

> ※ 読み込む画像によって値が異なる

**使用例（photo.jpg という画像ファイルをアップロードした場合）**

```python
from PIL import Image
path_to_file = '/content/drive/MyDrive/AI・データサイエンスツールⅣ/photo.jpg'
im1 = np.array(Image.open(path_to_file))

Image.fromarray(im1)  # ① （画像が表示される）
im1.ndim              # ② 3
im1.size              # ③ 36578304
im1.shape             # ④ (4032, 3024, 3)
```

### 画像の読み込み (2/2)

読み込む際に、画像のサイズや色を指定することができる。

> ※ 読み込む画像によって値や出力される画像が異なる

**使用例（前のページと同じ画像を使用）**

```python
im1_resize = np.array(Image.open(path_to_file).resize((256, 256)))
im1_gray = np.array(Image.open(path_to_file).convert('L'))

Image.fromarray(im1_resize)  # ① （画像が表示される）
Image.fromarray(im1_gray)    # ② （画像が表示される）
im1_resize.shape             # ③ (256, 256, 3)
im1_gray.shape               # ④ (4032, 3024)
```

### 画素値の取得と変更 (1/2)

インデックスを使って画素値の取得・変更を行うことができる。

- 行、列の順で指定する（開始地点は左上）
- 色（RGB）まで指定することも可能

> ※ 読み込む画像によって値や出力される画像が異なる

**使用例**

```python
path_to_file = '/content/drive/MyDrive/AI・データサイエンスツールⅣ/photo.jpg'
im1 = np.array(Image.open(path_to_file).resize((256, 256)))

im1[100, 100]    # ① R、G、B の値が出力される
                 # array([202, 202, 202], dtype=uint8)
im1[100, 100, 0] # ② R、G、B の一つの値を指定することも可能
                 # 202

im1[100, 100] = (255, 255, 255)  # インデクシングやスライシングで指定した範囲の色を変更
Image.fromarray(im1)             # ③ （画像が表示される）
```

### 画素値の取得と変更 (2/2)

画像の色については柔軟に変更することができる。

> ※ 読み込む画像によって出力される画像が異なる

**使用例**

```python
path_to_file = '/content/drive/MyDrive/AI・データサイエンスツールⅣ/photo.jpg'
im1 = np.array(Image.open(path_to_file).resize((256, 256)))

im1_green = im1.copy()
im1_green[:, :, (0, 2)] = 0  # G以外の値を0に変更

im1_rev = 255 - im1          # ネガポジ反転
im1_32 = im1 // 32 * 32      # 減色

Image.fromarray(np.hstack((im1, im1_green, im1_rev, im1_32)))  # ① （画像が表示される）
```

### 画像のトリミング

スライシングを使い、画像の一部を取り出すことができる。

- 画像の一部を別の色・画像に置き換えることもできる

> ※ 読み込む画像によって出力される画像が異なる

**使用例**

```python
path_to_file = '/content/drive/MyDrive/AI・データサイエンスツールⅣ/photo.jpg'
im1 = np.array(Image.open(path_to_file).resize((256, 256)))

Image.fromarray(im1[50:82, 50:82])    # ① 32×32 の領域を切り出し

im1[50:82, 50:82] = (255, 255, 255)   # 32×32 の領域を白に変更
Image.fromarray(im1)                   # ②

im2 = np.array(Image.open(path_to_file).resize((32, 32)))
im1[200:232, 200:232] = im2           # 32×32 の領域を別の画像に置き換え
Image.fromarray(im1)                   # ③
```

---

## Thank you!