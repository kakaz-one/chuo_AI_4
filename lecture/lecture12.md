# 第12回 データベースからのデータ抽出と集計

ver1.0.1  
最終更新日: 2022年12月15日

---

## 目次

- データ抽出と集計
  - GROUP BY 句
  - HAVING 句
  - 構成句の総合問題
- 集約関数と分析関数
- CASE文とクロス集計
  - CASE文
  - クロス集計

---

## データ抽出と集計

### GROUP BY 句

#### SQL構成句の並びと役割

| 構成句（並び順） | 役割 | 内部処理順 |
|---|---|---|
| SELECT | 表示するカラムを指定 | 6 |
| FROM | 参照元のテーブルを指定 | 1 |
| JOIN | 複数のテーブルを横結合 | 2 |
| WHERE | 条件抽出 | 3 |
| GROUP BY | 集約関数の集計単位を指定 | 4 |
| HAVING | 集約関数を使い条件抽出 | 5 |
| ORDER BY | 表示するデータの順番を並び替え | 7 |
| LIMIT | 表示するデータ数を制限 | 8 |

#### GROUP BY句の基本

GROUP BY句は、グループ化を行うためのカラム指定に使用する。「性別ごとの人数を数える」のように、主に「集約関数を利用して種類（区分）ごとに集計する」場合に用いる。

**基本構文**

```sql
SELECT
    グループ化するカラム名,
    集約関数(カラム名)
FROM
    テーブル名
GROUP BY
    グループ化するカラム名
;
```

**基本的な集約関数**

| 関数 | 処理内容 |
|---|---|
| AVG | 平均を返す |
| COUNT | アイテム数（レコード数）を返す |
| MAX | 最大値を返す |
| MIN | 最小値を返す |
| SUM | 合計を返す |
| STDDEV_POP | 母集団標準偏差を返す※ |
| STDDEV_SAMP | 標本標準偏差を返す※ |
| VAR_POP | 母集団分散を返す※ |
| VAR_SAMP | 標本分散を返す※ |

※ SQLite では利用できない

#### GROUP BY句 練習問題

**問題**: 「会員」テーブルから「未婚」の人の「性別」別の「平均年収」を求める

**【会員(user_mst)テーブル】**

| user_id | user_name | gender | age | blood | height | weight | addr | marriage | salary |
|---|---|---|---|---|---|---|---|---|---|
| 1 | 浅田平八 | 男 | 28 | A | 182 | 56 | 東京都 | 0 | 350 |
| 2 | 矢田まゆ | 女 | 30 | B | 165 | 54 | 神奈川県 | 1 | 280 |
| 3 | 島田りさ | 女 | 24 | AB | 152 | 39 | 埼玉県 | 0 | 260 |
| 4 | 水口五郎 | 男 | 35 | O | 176 | 68 | 千葉県 | 0 | 580 |
| 5 | 大和慶事 | 男 | 22 | B | 185 | 73 | 茨城県 | 0 | 320 |
| 6 | 高島亜里沙 | 女 | 18 | O | 148 | 41 | 東京都 | 0 | 95 |
| 7 | 安田紗江 | 女 | 28 | A | 154 | 47 | 埼玉県 | 0 | 290 |
| 8 | 田村哲平 | 男 | 32 | A | 178 | 69 | 神奈川県 | 0 | 520 |
| 9 | 五十嵐涼子 | 女 | 29 | B | 162 | 45 | 埼玉県 | 1 | 490 |
| 10 | 神田洋介 | 男 | 25 | O | 171 | 63 | 東京都 | 0 | 330 |
| 11 | 山口美穂 | 女 | 19 | AB | 169 | 49 | 千葉県 | 0 | 240 |
| 12 | 坂本卓也 | 男 | 39 | A | 164 | 59 | 神奈川県 | 2 | 720 |
| 13 | 辻本隼 | 男 | 26 | O | 156 | 65 | 東京都 | 0 | 430 |
| 14 | 君島理恵 | 女 | 27 | B | 155 | 42 | 千葉県 | 0 | 210 |
| 15 | 小池隆二 | 男 | 24 | A | 153 | 53 | 神奈川県 | 0 | 600 |

**解答**

```sql
SELECT
    gender,
    AVG(salary)
FROM
    user_mst
WHERE
    marriage = 0
GROUP BY
    gender
;
```

**実行結果**

| gender | salary |
|---|---|
| 女 | 219.0 |
| 男 | 447.1 |

#### GROUP BY句 複数キー

GROUP BY句では、複数の列をグループ化のキーにすることができる。例えば「住所」と「性別」の2列の組み合わせをグループ化キーにする場合には以下の構文に従う。

**注意**: SELECT句の要素は「GROUP BY句で指定したカラム」「集約関数」のみ記述できる。これが守られないクエリはエラーとなる。

**基本構文**

```sql
SELECT
    グループ化するカラム名1,
    グループ化するカラム名2,
    集約関数(カラム名)
FROM
    テーブル名
GROUP BY
    グループ化するカラム名1,
    グループ化するカラム名2
;
```

**練習問題**: 「会員」テーブルから「未婚」の人の「性別」、「住所」別の「平均年収」を求める

**解答**

```sql
SELECT
    gender,
    addr,
    AVG(salary)
FROM
    user_mst
WHERE
    marriage = 0
GROUP BY
    gender,
    addr
;
```

**実行結果**

| gender | addr | salary |
|---|---|---|
| 女 | 千葉県 | 225.0 |
| 女 | 埼玉県 | 275.0 |
| 女 | 東京都 | 95.0 |
| 男 | 千葉県 | 580.0 |
| 男 | 東京都 | 370.0 |
| 男 | 茨城県 | 320.0 |
| 男 | 神奈川県 | 560.0 |

---

### HAVING 句

HAVING句を使うと、グループ化の集約関数に対して条件指定ができる。HAVING句を使用することで、例えば「COUNT関数の実行結果が5以上のレコードを取り出す」といった処理を1つのクエリで記述できる。

**基本構文**

```sql
SELECT
    グループ化するカラム名,
    集約関数(カラム名)
FROM
    テーブル名
GROUP BY
    カラム名
HAVING
    集約関数を使った条件式
;
```

**例**: 「会員」テーブルから、「住所」別に「平均年収」を計算し、「平均年収」が330以上の「住所」を抽出する

```sql
SELECT
    addr,
    AVG(salary) AS 平均年収
FROM
    user_mst
GROUP BY
    addr
HAVING
    AVG(salary) >= 330
;
```

**実行結果**

| addr | 平均年収 |
|---|---|
| 神奈川県 | 530.0 |
| 千葉県 | 343.3 |
| 埼玉県 | 346.6 |

---

### 構成句の総合問題

#### 総合問題①

**問題**: 「会員」テーブルから以下の条件でレコードを抽出・集計せよ

- 「年齢」が20以上となるレコードを抽出し
- 「性別」「血液型」別に「平均身長」を求め
- 「平均身長」が155以上となるレコードを抽出し
- 「平均身長」の上位3行の「性別」「血液型」「平均身長」を表示する

**ヒント**: 内部処理順に構成句を考える

#### 総合問題②

**問題**: 「購買」テーブルから2回以上の購入がある会員を特定し、「会員」テーブルから該当の会員を抽出する

**【購買(purchase)テーブル】**

| user_id | sales_id | total_amount | order_dt | receive_dt |
|---|---|---|---|---|
| 10 | 10001 | 5000 | 2017-11-01 | 2017-11-04 |
| 14 | 10002 | 10000 | 2017-11-02 | 2017-11-05 |
| 8 | 10003 | 3000 | 2017-11-02 | 2017-11-05 |
| 1 | 10004 | 2000 | 2017-11-03 | |
| 6 | 10005 | 3500 | 2017-11-04 | 2017-11-07 |
| 10 | 10006 | 5000 | 2017-11-05 | 2017-11-08 |
| 6 | 10007 | 8000 | 2017-11-07 | 2017-11-10 |
| 6 | 10008 | 6000 | 2017-11-09 | |
| 5 | 10009 | 3000 | 2017-11-12 | 2017-11-15 |
| 3 | 10010 | 9000 | 2017-11-12 | 2017-11-15 |
| 1 | 10011 | 1000 | 2017-11-14 | |
| 17 | 10012 | 10000 | 2017-11-15 | 2017-11-18 |

表示カラムは「個人ID」「名前」「購買回数」とする。

---

## 集約関数と分析関数

### 集約関数と分析関数の違い

- **集約関数**: グループごとに1つの集計結果を返す（集約あり）
- **分析関数**: 元のテーブルの各行に対して結果を返す（集約なし）

**分析関数のメリット**

1. **問い合わせ速度の向上**
   - 集計を行うためには、内部結合や複雑な処理手続きが必要である
   - 分析関数により、簡素なSQL文で記述することが可能となり、処理パフォーマンスも向上できる

2. **開発作業の効率化**
   - 明快で簡潔なSQL文で、複雑な分析処理の記述が可能となる

### 分析関数の分類

分析関数は Window関数 とも呼ばれる。

| 分類 | 使用例 |
|---|---|
| ランク付け関数群 | 結果セットのグループのランキングを計算する |
| ウィンドウ関数群 | 累積集計を計算する |
| レポート関数群 | 市場占有率などのシェアを計算する |
| ラグ／リード関数群 | 前月との比較を計算する |
| 線形回帰関数群 | 統計情報（傾き、切片など）を計算する |

### 代表的な分析関数

よく利用するのは RANK()、ROW_NUMBER()、DENSE_RANK() であり、()内には何も書かなくてよい。集約関数を分析関数として使用することもできる。

| 関数 | 処理内容 |
|---|---|
| ROW_NUMBER() | 行番号 |
| RANK() | ランキング (同率で番号を飛ばす) |
| DENSE_RANK() | ランキング (同率で番号を飛ばさない) |
| PERCENT_RANK() | ランキング (%で表示) : (RANK - 1) / (全行数 - 1) |
| CUME_DIST() | PERCENT_RANK に類似 : (現在の行の位置) / (全行数) |
| NTILE(N) | ランキング (1..N に分割) |
| LAG(value, offset, default) | ソート状態での前の行の値 |
| LEAD(value, offset, default) | ソート状態での後の行の値 |
| FIRST_VALUE(value) | 最初の値 |
| LAST_VALUE(value) | 最後の値 |
| NTH_VALUE(value, N) | N番目の値 (1から数える) |

出典：ウインドウ関数（Window Functions) https://www.postgresql.org/docs/9.1/static/functions-window.html

### 分析関数の操作

分析関数の操作は以下の3つのステップに分けられる：

1. **PARTITION句によるグループの指定**
2. **ORDER BY句によるレコードの整列**
3. **フレーム句によるフレームの定義**

### 分析関数の書き方

分析関数では3つのステップをOVER()の中に記載する。

- PARTITION BYでグループを指定する
- ORDER BYでグループ内の並べ替えを制御する
- フレーム句で集計対象となるレコードの範囲を指定する

**基本構文**

```sql
SELECT
    *,
    -- テーブル全体を１つのグループとする
    分析関数 OVER(),
    -- グループ単位の指定と並べ替え
    分析関数 OVER(PARTITION BY カラム名 ORDER BY カラム名),
    -- グループ単位の指定と並べ替え、フレームの指定
    分析関数 OVER(PARTITION BY カラム名 ORDER BY カラム名 フレーム句)
FROM
    テーブル名
;
```

**例**: テーブル全体のレコード数と「住所」カラムごとのレコード数を出力する

```sql
SELECT
    user_name,
    addr,
    COUNT(*) OVER() AS all_cnt,
    COUNT(*) OVER(PARTITION BY addr) AS addr_cnt
FROM
    user_mst
;
```

**実行結果**

| user_name | addr | all_cnt | addr_cnt |
|---|---|---|---|
| 水口五郎 | 千葉県 | 15 | 3 |
| 山口美穂 | 千葉県 | 15 | 3 |
| 君島理恵 | 千葉県 | 15 | 3 |
| 島田りさ | 埼玉県 | 15 | 3 |
| 安田紗江 | 埼玉県 | 15 | 3 |
| 五十嵐涼子 | 埼玉県 | 15 | 3 |
| 浅田平八 | 東京都 | 15 | 4 |
| 高島亜里沙 | 東京都 | 15 | 4 |
| 神田洋介 | 東京都 | 15 | 4 |
| 辻本隼 | 東京都 | 15 | 4 |
| 矢田まゆ | 神奈川県 | 15 | 4 |
| 田村哲平 | 神奈川県 | 15 | 4 |
| 坂本卓也 | 神奈川県 | 15 | 4 |
| 小池隆二 | 神奈川県 | 15 | 4 |
| 大和慶事 | 茨城県 | 15 | 1 |

### フレーム句

フレーム句を用いて、処理を行っている現在の行を基準としてフレーム(分析関数の集計の対象となるレコード)を指定する。

| フレーム句 | 処理内容 |
|---|---|
| UNBOUNDED PRECEDING | フレームの開始位置をパーティション開始位置に設定する |
| UNBOUNDED FOLLOWING | フレームの終了位置をパーティション終了位置に設定する |
| offset PRECEDING | 現在の行を基準にして、offset(整数値)分だけ前のデータからフレームに加える |
| offset FOLLOWING | 現在の行を基準にして、offset(整数値)分だけ後のデータまでフレームに加える |

**注意**: 
- フレーム句を指定しない場合、対象はグループ内の先頭レコードから現在のレコードまでとなる
- RANK()、ROW_NUMBER()、DENSE_RANK() ではフレーム句を使わない

**例**: 購買テーブルから合計金額の累積和と3レコードの累積和を求める

```sql
SELECT
    total_amount,
    SUM(total_amount) OVER() AS cum,
    SUM(total_amount) OVER(ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving
FROM
    purchase
;
```

**実行結果**

| total_amount | cum | moving |
|---|---|---|
| 5000 | 65500 | 5000 |
| 10000 | 65500 | 15000 |
| 3000 | 65500 | 18000 |
| 2000 | 65500 | 15000 |
| 3500 | 65500 | 8500 |
| 5000 | 65500 | 10500 |
| 8000 | 65500 | 16500 |
| 6000 | 65500 | 19000 |
| 3000 | 65500 | 17000 |
| 9000 | 65500 | 18000 |
| 1000 | 65500 | 13000 |
| 10000 | 65500 | 20000 |

### 分析関数 練習問題

#### 練習1: 平均年齢

**問題**: 分析関数を利用して、全体の平均年齢を求める列を追加するSQLを作る

**ヒント**: 「全体の」：OVER()を使う。PARTITION BYは不要

**解答**

```sql
SELECT
    *,
    AVG(age) OVER () AS avg_age
FROM
    user_mst
;
```

**実行結果**（一部）

| user_id | user_name | gender | age | salary | avg_age |
|---|---|---|---|---|---|
| 1 | 浅田平八 | 男 | 28 | 350 | 27.06666667 |
| 2 | 矢田まゆ | 女 | 30 | 280 | 27.06666667 |
| ... | ... | ... | ... | ... | 27.06666667 |

#### 練習2: 男女別身長順

**問題**: 男女別に「身長」の高い順に並べ替えた時の順番を求める列(男女別身長順)を追加する

**ヒント**: 分析関数「ROW_NUMBER()」を使う

---

## CASE文とクロス集計

### CASE文

CASE文の使用により、クエリ内で条件分岐することができる。以下に示すように、2通りの書き方があるが、汎用性が高いパターン1の書き方を推奨する。

**パターン1（推奨）**

```sql
SELECT
    CASE
        WHEN 条件1 THEN 結果1
        WHEN 条件2 THEN 結果2
        ELSE デフォルト値
    END AS 出力カラム名
FROM
    テーブル名
;
```

**パターン2**

```sql
SELECT
    CASE 対象カラム名
        WHEN 条件値1 THEN 結果1
        WHEN 条件値2 THEN 結果2
        ELSE デフォルト値
    END AS 出力カラム名
FROM
    テーブル名
;
```

**例**: 「会員」テーブルで、「結婚回数」が0回の場合は「未婚」、1回以上の場合は「既婚／離婚」とし、「結婚履歴」として出力する

```sql
SELECT
    user_id,
    user_name,
    marriage,
    CASE
        WHEN marriage = 0 THEN '未婚'
        ELSE '既婚／離婚'
    END AS marriage_status
FROM
    user_mst
;
```

**実行結果**

| user_id | user_name | marriage | marriage_status |
|---|---|---|---|
| 1 | 浅田平八 | 0 | 未婚 |
| 2 | 矢田まゆ | 1 | 既婚／離婚 |
| 3 | 島田りさ | 0 | 未婚 |
| ... | ... | ... | ... |

### CASE文 練習問題

**問題**: 「会員」テーブルを10歳刻みの年齢階級（例：10代、20代・・・）に分類して「年齢階級(age_class)」という名称で出力する。「個人ID」、「名前」、「性別」、「年齢階級」のみ出力する。

**解答**

```sql
SELECT
    user_id,
    user_name,
    gender,
    CASE
        WHEN age >= 10 AND age <= 19 THEN '10代'
        WHEN age >= 20 AND age <= 29 THEN '20代'
        WHEN age >= 30 AND age <= 39 THEN '30代'
        ELSE 'その他'
    END AS age_class
FROM
    user_mst
;
```

**実行結果**

| user_id | user_name | gender | age_class |
|---|---|---|---|
| 1 | 浅田平八 | 男 | 20代 |
| 2 | 矢田まゆ | 女 | 30代 |
| 3 | 島田りさ | 女 | 20代 |
| 4 | 水口五郎 | 男 | 30代 |
| 5 | 大和慶事 | 男 | 20代 |
| 6 | 高島亜里沙 | 女 | 10代 |
| 7 | 安田紗江 | 女 | 20代 |
| 8 | 田村哲平 | 男 | 30代 |
| 9 | 五十嵐涼子 | 女 | 20代 |
| 10 | 神田洋介 | 男 | 20代 |
| 11 | 山口美穂 | 女 | 10代 |
| 12 | 坂本卓也 | 男 | 30代 |
| 13 | 辻本隼 | 男 | 20代 |
| 14 | 君島理恵 | 女 | 20代 |
| 15 | 小池隆二 | 男 | 20代 |

---

### クロス集計

CASE文とGROUP BYを組み合わせることでクロス集計表が作成できる。クロス集計表は機械学習の入力にも利用できるので、非常に重要なテクニックである。

**基本構文**

```sql
SELECT
    表側カラム名,
    SUM(CASE WHEN 条件式1 THEN 1 ELSE 0 END) AS 条件1カウント数,
    SUM(CASE WHEN 条件式2 THEN 1 ELSE 0 END) AS 条件2カウント数
FROM
    テーブル
GROUP BY
    表側カラム名
ORDER BY
    表側カラム名
;
```

**用語**
- 表側（ひょうそく）: クロス集計表の行方向の項目
- 表頭（ひょうとう）: クロス集計表の列方向の項目

**例**: 「会員」テーブルから「血液型」と「性別」のクロス集計表を作成する

- 表側: 「血液型」
- 表頭: 「男」「女」のカウント数

```sql
SELECT
    blood,
    SUM(CASE WHEN gender = '男' THEN 1 ELSE 0 END) AS 男,
    SUM(CASE WHEN gender = '女' THEN 1 ELSE 0 END) AS 女
FROM
    user_mst
GROUP BY
    blood
ORDER BY
    blood
;
```

**実行結果**

| 血液型 | 男 | 女 |
|---|---|---|
| A | 4 | 1 |
| AB | 0 | 2 |
| B | 1 | 3 |
| O | 3 | 1 |

### クロス集計 練習問題

**問題**: 以下のようなクロス表を作成する

- 表側:「個人ID」
- 表頭:「男性フラグ(男性は1、女性は0)」、「身長」、「体重」

**解答**

```sql
SELECT
    user_id,
    -- 目的変数
    MAX(CASE WHEN gender = '男' THEN 1 ELSE 0 END) man_flag,
    -- 説明変数
    MAX(height) height,
    MAX(weight) weight
FROM
    user_mst
GROUP BY
    user_id
ORDER BY
    user_id
;
```

**実行結果**

| user_id | man_flag | height | weight |
|---|---|---|---|
| 1 | 1 | 182 | 56 |
| 2 | 0 | 165 | 54 |
| 3 | 0 | 152 | 39 |
| 4 | 1 | 176 | 68 |
| 5 | 1 | 185 | 73 |
| 6 | 0 | 148 | 41 |
| 7 | 0 | 154 | 47 |
| 8 | 1 | 178 | 69 |
| 9 | 0 | 162 | 45 |
| 10 | 1 | 171 | 63 |
| 11 | 0 | 169 | 49 |
| 12 | 1 | 164 | 59 |
| 13 | 1 | 156 | 65 |
| 14 | 0 | 155 | 42 |
| 15 | 1 | 153 | 53 |

---

## 章末課題

**問題**: 以下のクエリがエラーになる原因として、正しいものを選択せよ

```sql
SELECT
    user_id,
    SUM(total_amount)
FROM
    purchase
GROUP BY
    user_id
WHERE
    total_amount >= 10000
;
```

**選択肢**

1. SUM()は必ずOVER()と組み合わせる必要があるため
2. GROUP BY のキーとして total_amount が指定されていないため
3. WHERE句が GROUP BY句よりも後ろにあるため
4. ORDER BY句がないため

**解答**: ③ WHERE句が GROUP BY句よりも後ろにあるため

（SQLの構文では、WHERE句はGROUP BY句よりも前に記述する必要がある）

---

Copyright © 2023 Accenture. All rights reserved.