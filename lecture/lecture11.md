# 第11回 テーブルの結合

**ver1.0.2**  
**最終更新日: 2025年12月10日**

---

## 目次

- [複数のテーブルの結合](#複数のテーブルの結合)
  - [JOIN](#join)
  - [UNION](#union)
- [SELECT文の入れ子](#select文の入れ子)
  - [副問い合わせ](#副問い合わせ)
  - [WITH句](#with句)
- [（参考）CROSS JOIN](#参考cross-join)

---

## 複数のテーブルの結合

### 結合とは

**結合とは、複数の表（テーブル）から1つの表にする操作のことである**

SQLでは、**横結合**と**縦結合**が存在する。

| 結合の種類 | SQL句 | 説明 |
|:---|:---|:---|
| 横結合 | JOIN | テーブルを横に並べて結合 |
| 縦結合 | UNION | テーブルを縦に並べて結合 |

#### JOIN（横結合）の例

**売上データ**

| 売上番号 | 商品コード | 数量 |
|:---:|:---:|:---:|
| 1 | 10 | 5 |
| 2 | 30 | 1 |
| 3 | 20 | 3 |
| 4 | 30 | 2 |
| 5 | 10 | 1 |

**商品データ**

| 商品コード | 商品名 | 単価 |
|:---:|:---|:---:|
| 10 | 鉛筆 | 10 |
| 20 | ボールペン | 100 |
| 30 | ノート | 150 |

**↓ 結合後**

| 売上番号 | 数量 | 売上データ.商品コード | 商品データ.商品コード | 商品名 | 単価 |
|:---:|:---:|:---:|:---:|:---|:---:|
| 1 | 5 | 10 | 10 | 鉛筆 | 10 |
| 2 | 1 | 30 | 30 | ノート | 150 |
| 3 | 3 | 20 | 20 | ボールペン | 100 |
| 4 | 2 | 30 | 30 | ノート | 150 |
| 5 | 1 | 10 | 10 | 鉛筆 | 10 |

#### UNION（縦結合）の例

**売上データA**

| 売上番号 | 商品コード | 数量 |
|:---:|:---:|:---:|
| 1 | 10 | 5 |
| 2 | 30 | 1 |
| 3 | 20 | 3 |
| 4 | 30 | 2 |
| 5 | 10 | 1 |

**売上データB**

| 売上番号 | 商品コード | 数量 |
|:---:|:---:|:---:|
| 6 | 20 | 2 |
| 7 | 20 | 3 |

**↓ 結合後**

| 売上番号 | 商品コード | 数量 |
|:---:|:---:|:---:|
| 1 | 10 | 5 |
| 2 | 30 | 1 |
| 3 | 20 | 3 |
| 4 | 30 | 2 |
| 5 | 10 | 1 |
| 6 | 20 | 2 |
| 7 | 20 | 3 |

---

## JOIN

### JOIN句の並びと役割

SQL文における各句の**内部処理順**と役割を以下に示す。

| 内部処理順 | 構成句（並び順） | 役割 |
|:---:|:---|:---|
| 6 | SELECT | 表示するカラムを指定 |
| 1 | FROM | 参照元のテーブルを指定 |
| 5 | HAVING | 集約関数を使い条件抽出 |
| 2 | JOIN | 複数のテーブルを横結合 |
| 3 | WHERE | 条件抽出 |
| 4 | GROUP BY | 集約関数の集計単位を指定 |
| 8 | LIMIT | 表示するデータ数を制限 |
| 7 | ORDER BY | 表示するデータの順番を並び替え |

### JOINとは

**JOINは、複数のテーブルを横に並べ1つのテーブルにする操作のことである**

- 結合の種類（INNER, LEFT, ...）と各テーブルの結合カラムを指定する必要がある

#### 例：売上データと商品データを商品コードで結合する

**売上データ**

| 売上番号 | 商品コード | 数量 |
|:---:|:---:|:---:|
| 1 | 10 | 5 |
| 2 | 30 | 1 |
| 3 | 20 | 3 |
| 4 | 30 | 2 |
| 5 | 10 | 1 |

**商品データ**

| 商品コード | 商品名 | 単価 |
|:---:|:---|:---:|
| 10 | 鉛筆 | 10 |
| 20 | ボールペン | 100 |
| 30 | ノート | 150 |

**↓ 結合後**

| 売上番号 | 数量 | 売上データ.商品コード | 商品データ.商品コード | 商品名 | 単価 |
|:---:|:---:|:---:|:---:|:---|:---:|
| 1 | 5 | 10 | 10 | 鉛筆 | 10 |
| 2 | 1 | 30 | 30 | ノート | 150 |
| 3 | 3 | 20 | 20 | ボールペン | 100 |
| 4 | 2 | 30 | 30 | ノート | 150 |
| 5 | 1 | 10 | 10 | 鉛筆 | 10 |

---

### JOINの種類

JOINには、以下のような種類がある。

| SQL | 名前 | 説明 |
|:---|:---|:---|
| INNER JOIN | 内部結合 | 左右両方のテーブルに共通する行を残す |
| LEFT JOIN | 左外部結合 | 左のテーブルを基準に、右のテーブルに存在するデータを結合する |
| RIGHT JOIN | 右外部結合 | 右のテーブルを基準に、左のテーブルに存在するデータを結合する |
| FULL JOIN | 完全外部結合 | 左右すべてのデータを残す |

> **Note**: 上記の他に、CROSS JOIN（交差結合）がある（「（参考）CROSS JOIN」で紹介する）

#### 各JOINの概念図

| JOINの種類 | 説明 |
|:---|:---|
| **INNER JOIN** | 左右のテーブルに共通して存在するデータ（行）を残す |
| **LEFT JOIN** | 左のテーブルはすべてのデータを残し、右のテーブルは左との共通部分のみ残す |
| **RIGHT JOIN** | 右のテーブルはすべてのデータを残し、左のテーブルは右との共通部分のみ残す |
| **FULL JOIN** | 左右のテーブルのデータをすべて残す |

---

### INNER JOIN（内部結合）

**INNER JOIN（内部結合）は、左右両方の表に存在するデータのみ残る**

- ONに結合キーにするカラムを指定する

#### 基本構文

```sql
SELECT 
    * 
FROM 
    左テーブル
INNER JOIN
    右テーブル
ON 
    左テーブル.カラム名 = 右テーブル.カラム名
;
```

#### クエリの例

**テーブル名：名簿**

| id | 名前 | 年齢 | 生年月日 | 住所コード |
|:---:|:---|:---:|:---|:---:|
| 1 | Taro | 18 | 1997-08-07 | 101 |
| 2 | Jiro | 16 | 1999-08-11 | 103 |
| 3 | Saburo | 30 | 1985-08-11 | 101 |
| 4 | Shiro | 10 | 2005-08-17 | 105 |

**テーブル名：住所**

| コード | 住所 |
|:---:|:---|
| 101 | Tokyo |
| 102 | Osaka |
| 103 | Kanagawa |
| 104 | Hokkaido |

```sql
SELECT 
    * 
FROM 
    名簿
INNER JOIN
    住所
ON 
    名簿.住所コード = 住所.コード
;
```

#### 実行結果

| id | 名前 | 年齢 | 生年月日 | 住所コード | コード | 住所 |
|:---:|:---|:---:|:---|:---:|:---:|:---|
| 1 | Taro | 18 | 1997-08-07 | 101 | 101 | Tokyo |
| 2 | Jiro | 16 | 1999-08-11 | 103 | 103 | Kanagawa |
| 3 | Saburo | 30 | 1985-08-11 | 101 | 101 | Tokyo |

> Shiro（住所コード：105）は住所テーブルに存在しないため、結果に含まれない

---

### LEFT JOIN（左外部結合）

**LEFT JOIN（左結合）では、左側の表のすべてのデータが残り、右側の表は左側の表に存在するデータのみ残る**

- RIGHT JOINでは、LEFT JOINと左右逆の操作になる

#### 基本構文

```sql
SELECT
    * 
FROM 
    左テーブル
LEFT JOIN
    右テーブル
ON
    左テーブル.カラム名 = 右テーブル.カラム名
;
```

#### クエリの例

**テーブル名：名簿**

| id | 名前 | 年齢 | 生年月日 | 住所コード |
|:---:|:---|:---:|:---|:---:|
| 1 | Taro | 18 | 1997-08-07 | 101 |
| 2 | Jiro | 16 | 1999-08-11 | 103 |
| 3 | Saburo | 30 | 1985-08-11 | 101 |
| 4 | Shiro | 10 | 2005-08-17 | 105 |

**テーブル名：住所**

| コード | 住所 |
|:---:|:---|
| 101 | Tokyo |
| 102 | Osaka |
| 103 | Kanagawa |
| 104 | Hokkaido |

```sql
SELECT
    * 
FROM 
    名簿
LEFT JOIN
    住所
ON
    名簿.住所コード = 住所.コード
;
```

#### 実行結果

| id | 名前 | 年齢 | 生年月日 | 住所コード | コード | 住所 |
|:---:|:---|:---:|:---|:---:|:---:|:---|
| 1 | Taro | 18 | 1997-08-07 | 101 | 101 | Tokyo |
| 2 | Jiro | 16 | 1999-08-11 | 103 | 103 | Kanagawa |
| 3 | Saburo | 30 | 1985-08-11 | 101 | 101 | Tokyo |
| 4 | Shiro | 10 | 2005-08-17 | 105 | | |

> **Note**: 右テーブルに対応するデータがない場合、右テーブルのカラムは**NULL**となる

---

### JOIN 練習問題

#### 使用するテーブル

**【会員(user_mst)テーブル】**

| 個人ID | 名前 | 性別 | 年齢 | 血液型 | 身長 | 体重 | 住所 | 結婚回数 | 年収 |
|:---:|:---|:---:|:---:|:---:|:---:|:---:|:---|:---:|:---:|
| 1 | 浅田平八 | 男 | 28 | A | 182 | 56 | 東京都 | 0 | 350 |
| 2 | 矢田まゆ | 女 | 30 | B | 165 | 54 | 神奈川県 | 1 | 280 |
| 3 | 島田りさ | 女 | 24 | AB | 152 | 39 | 埼玉県 | 0 | 260 |
| 4 | 水口五郎 | 男 | 35 | O | 176 | 68 | 千葉県 | 0 | 580 |
| 5 | 大和慶事 | 男 | 22 | B | 185 | 73 | 茨城県 | 0 | 320 |
| 6 | 高島亜里沙 | 女 | 18 | O | 148 | 41 | 東京都 | 0 | 95 |
| 7 | 安田紗江 | 女 | 28 | A | 154 | 47 | 埼玉県 | 0 | 290 |
| 8 | 田村哲平 | 男 | 32 | A | 178 | 69 | 神奈川県 | 0 | 520 |
| 9 | 五十嵐涼子 | 女 | 29 | B | 162 | 45 | 埼玉県 | 1 | 490 |
| 10 | 神田洋介 | 男 | 25 | O | 171 | 63 | 東京都 | 0 | 330 |
| 11 | 山口美穂 | 女 | 19 | AB | 169 | 49 | 千葉県 | 0 | 240 |
| 12 | 坂本卓也 | 男 | 39 | A | 164 | 59 | 神奈川県 | 2 | 720 |
| 13 | 辻本隼 | 男 | 26 | O | 156 | 65 | 東京都 | 0 | 430 |
| 14 | 君島理恵 | 女 | 27 | B | 155 | 42 | 千葉県 | 0 | 210 |
| 15 | 小池隆二 | 男 | 24 | A | 153 | 53 | 神奈川県 | 0 | 600 |

**【購買(purchase)テーブル】**

| 個人ID | 購買ID | 合計金額 | 注文日 | 受取日 |
|:---:|:---:|:---:|:---|:---|
| 10 | 10001 | 5000 | 2017-11-01 | 2017-11-04 |
| 14 | 10002 | 10000 | 2017-11-02 | 2017-11-05 |
| 8 | 10003 | 3000 | 2017-11-02 | 2017-11-05 |
| 1 | 10004 | 2000 | 2017-11-03 | |
| 6 | 10005 | 3500 | 2017-11-04 | 2017-11-07 |
| 10 | 10006 | 5000 | 2017-11-05 | 2017-11-08 |
| 6 | 10007 | 8000 | 2017-11-07 | 2017-11-10 |
| 6 | 10008 | 6000 | 2017-11-09 | |
| 5 | 10009 | 3000 | 2017-11-12 | 2017-11-15 |
| 3 | 10010 | 9000 | 2017-11-12 | 2017-11-15 |
| 1 | 10011 | 1000 | 2017-11-14 | |
| 17 | 10012 | 10000 | 2017-11-15 | 2017-11-18 |

---

#### 練習1：LEFT JOIN

**問題**: 「会員」テーブルと「購買」テーブルを「個人ID」をキーとして結合し、「個人ID」、「性別」、「年齢」、「購買ID」、「合計金額」を表示する

- 「会員」テーブルに対し、「購買」テーブルを左結合する

##### 解答

```sql
SELECT
    usr.user_id
    , usr.gender
    , usr.age
    , p.sales_id
    , p.total_amount
FROM
    user_mst usr
LEFT JOIN purchase p
ON
    usr.user_id = p.user_id
;
```

##### 実行結果

| 個人ID | 性別 | 年齢 | 購買ID | 合計金額 |
|:---:|:---:|:---:|:---:|:---:|
| 1 | 男 | 28 | 10011 | 1000 |
| 1 | 男 | 28 | 10004 | 2000 |
| 2 | 女 | 30 | | |
| 3 | 女 | 24 | 10010 | 9000 |
| 4 | 男 | 35 | | |
| 5 | 男 | 22 | 10009 | 3000 |
| 6 | 女 | 18 | 10008 | 6000 |
| 6 | 女 | 18 | 10005 | 3500 |
| 6 | 女 | 18 | 10007 | 8000 |
| 7 | 女 | 28 | | |
| 8 | 男 | 32 | 10003 | 3000 |
| 9 | 女 | 29 | | |
| 10 | 男 | 25 | 10001 | 5000 |
| 10 | 男 | 25 | 10006 | 5000 |
| 11 | 女 | 19 | | |
| 12 | 男 | 39 | | |
| 13 | 男 | 26 | | |
| 14 | 女 | 27 | 10002 | 10000 |
| 15 | 男 | 24 | | |

---

#### 練習2：INNER JOIN

**問題**: 「会員」テーブルと「購買」テーブルを「個人ID」をキーとして内部結合し、合計金額が高い順になるように並び替え、「名前」「合計金額」を表示せよ

---

## UNION

### UNIONとは

**UNIONによって、カラム構成が同じクエリ結果を縦に結合できる**

- 複数のSELECTの結果で重複する行がある場合、重複行は削除する
- 複数のSELECTの結果で重複する行がある場合でも、**UNION ALL**を使うと重複行を含めることができる

> **Note**: 集合演算子には差集合を求めるMINUS、EXCEPTなども存在する

#### 例：売上データAと売上データBを縦につなげる

**売上データA**

| 売上番号 | 商品コード | 数量 |
|:---:|:---:|:---:|
| 1 | 10 | 5 |
| 2 | 30 | 1 |
| 3 | 20 | 3 |
| 4 | 30 | 2 |
| 5 | 10 | 1 |

**売上データB**

| 売上番号 | 商品コード | 数量 |
|:---:|:---:|:---:|
| 6 | 20 | 2 |
| 7 | 20 | 3 |

**↓ 結合後**

| 売上番号 | 商品コード | 数量 |
|:---:|:---:|:---:|
| 1 | 10 | 5 |
| 2 | 30 | 1 |
| 3 | 20 | 3 |
| 4 | 30 | 2 |
| 5 | 10 | 1 |
| 6 | 20 | 2 |
| 7 | 20 | 3 |

### 基本構文

```sql
SELECT
    * 
FROM 
    売上データA
UNION
SELECT
    * 
FROM 
    売上データB
;
```

---

### UNION 練習問題

**問題**: 「購買」テーブルから 条件①「合計金額が5000以上」、条件②「購買IDが10005以下」という条件をそれぞれ別のクエリにして、縦結合する

- 重複は許し、すべてのカラムを表示する

**条件①で抽出したデータ**

| 個人ID | 購買ID | 合計金額 | 注文日 | 受取日 |
|:---:|:---:|:---:|:---|:---|
| 10 | 10001 | 5000 | 2017-11-01 | 2017-11-04 |
| 14 | 10002 | 10000 | 2017-11-02 | 2017-11-05 |
| 10 | 10006 | 5000 | 2017-11-05 | 2017-11-08 |
| 6 | 10007 | 8000 | 2017-11-07 | 2017-11-10 |
| 6 | 10008 | 6000 | 2017-11-09 | |
| 3 | 10010 | 9000 | 2017-11-12 | 2017-11-15 |
| 17 | 10012 | 10000 | 2017-11-15 | 2017-11-18 |

**条件②で抽出したデータ**

| 個人ID | 購買ID | 合計金額 | 注文日 | 受取日 |
|:---:|:---:|:---:|:---|:---|
| 10 | 10001 | 5000 | 2017-11-01 | 2017-11-04 |
| 14 | 10002 | 10000 | 2017-11-02 | 2017-11-05 |
| 8 | 10003 | 3000 | 2017-11-02 | 2017-11-05 |
| 1 | 10004 | 2000 | 2017-11-03 | |
| 6 | 10005 | 3500 | 2017-11-04 | 2017-11-07 |

#### 解答

```sql
SELECT *
FROM purchase AS A
WHERE total_amount >= 5000
UNION ALL
SELECT *
FROM purchase AS B
WHERE sales_id <= '10005'
;
```

#### 実行結果

| 個人ID | 購買ID | 合計金額 | 注文日 | 受取日 |
|:---:|:---:|:---:|:---|:---|
| 10 | 10001 | 5000 | 2017-11-01 | 2017-11-04 |
| 14 | 10002 | 10000 | 2017-11-02 | 2017-11-05 |
| 10 | 10006 | 5000 | 2017-11-05 | 2017-11-08 |
| 6 | 10007 | 8000 | 2017-11-07 | 2017-11-10 |
| 6 | 10008 | 6000 | 2017-11-09 | |
| 3 | 10010 | 9000 | 2017-11-12 | 2017-11-15 |
| 17 | 10012 | 10000 | 2017-11-15 | 2017-11-18 |
| 10 | 10001 | 5000 | 2017-11-01 | 2017-11-04 |
| 14 | 10002 | 10000 | 2017-11-02 | 2017-11-05 |
| 8 | 10003 | 3000 | 2017-11-02 | 2017-11-05 |
| 1 | 10004 | 2000 | 2017-11-03 | |
| 6 | 10005 | 3500 | 2017-11-04 | 2017-11-07 |

---

## SELECT文の入れ子

### SELECT文の入れ子とは

**入れ子にすることで、SELECT文の結果を次のSELECT文で使用できる**

入れ子にする記法は「**副問合せ**」と「**WITH句**」がある。

- 複数のSELECT文を書き分けやすく、可読性の高さから「**WITH句**」の記法を推奨する

#### 副問合せの構造

```
SELECT文3
  └── SELECT文2
        └── SELECT文1
```

（SELECT文が内側から外側へネストされている）

#### WITH句の構造

```
SELECT文1 → SELECT文2 → SELECT文3
```

（SELECT文が順番に定義され、参照される）

---

## 副問い合わせ

### 副問い合わせとは

**クエリの中にクエリを差し込むことを「副問い合わせ(sub query)」という**

- 副問い合わせにより、複数のクエリを逐次実行したデータの絞り込み・加工が可能になる
- 結合やINと組み合わせて使うこともある

### 基本構文

```sql
SELECT
    カラム
FROM (
    SELECT カラム
    FROM テーブル
) AS 別のテーブル名
;
```

---

### 副問い合わせ 練習問題

**問題**: 「購買」テーブルに購入履歴がある会員について、「会員」テーブルから該当の会員の「個人ID」、「名前」、「性別」、「年齢」を抽出する

**【ヒント】** INNER JOIN または IN を使う

#### 解答1：INNER JOINを使用

```sql
SELECT
    U.user_id
    , user_name
    , gender
    , age
FROM
    user_mst AS U
INNER JOIN (
    SELECT
        DISTINCT user_id
    FROM
        purchase
) AS A
    ON U.user_id = A.user_id
;
```

#### 解答2：INを使用

```sql
SELECT
    U.user_id
    , user_name
    , gender
    , age
FROM
    user_mst AS U
WHERE user_id IN (
    SELECT
        DISTINCT user_id
    FROM
        purchase
) ;
```

#### 実行結果

| 個人ID | 名前 | 性別 | 年齢 |
|:---:|:---|:---:|:---:|
| 1 | 浅田平八 | 男 | 28 |
| 3 | 島田りさ | 女 | 24 |
| 5 | 大和慶事 | 男 | 22 |
| 6 | 高島亜里沙 | 女 | 18 |
| 8 | 田村哲平 | 男 | 32 |
| 10 | 神田洋介 | 男 | 25 |
| 14 | 君島理恵 | 女 | 27 |

---

## WITH句

### WITH句とは

**WITH句は、複数のクエリを逐次実行する方法である**

- 各SELECT文の実行結果を一連の処理終了まで一時的に保持し、それを再利用できるため、一時テーブルをいくつも作成する必要がなくなる

> **Note**: 比較的複雑な結果を求める際にWITH句を使用するため、結果的に長いSQL文になってしまうことが多い。完成形を明確にし、それを実現するためのロジックを構築することが非常に重要となる。

### 基本構文

#### 一時テーブルが1つの場合

```sql
WITH 一時テーブル1 AS (
    SELECT カラム名 
    FROM テーブル名
)
SELECT カラム名
FROM 一時テーブル1
;
```

#### 一時テーブルが複数の場合

```sql
WITH 一時テーブル1 AS (
    SELECT カラム名
    FROM テーブル名
)
, 一時テーブル2 AS (
    SELECT カラム名
    FROM 一時テーブル1
)
SELECT カラム名
FROM 一時テーブル2
;
```

---

### WITH句 練習問題

**問題**: 「購買」テーブルに購入履歴がある会員について、「会員」テーブルから該当の会員の「個人ID」、「名前」、「性別」、「年齢」を抽出する

**【ヒント】** INNER JOIN を使う

#### 解答

```sql
WITH A AS 
(SELECT
    DISTINCT user_id
    FROM
    purchase
)
SELECT
    U.user_id
    , user_name
    , gender
    , age
FROM
    user_mst AS U
INNER JOIN
    A
ON U.user_id = A.user_id
;
```

#### 実行結果

| 個人ID | 名前 | 性別 | 年齢 |
|:---:|:---|:---:|:---:|
| 1 | 浅田平八 | 男 | 28 |
| 3 | 島田りさ | 女 | 24 |
| 5 | 大和慶事 | 男 | 22 |
| 6 | 高島亜里沙 | 女 | 18 |
| 8 | 田村哲平 | 男 | 32 |
| 10 | 神田洋介 | 男 | 25 |
| 14 | 君島理恵 | 女 | 27 |

---

### WITH句 応用練習問題

**問題**: 「名前」に「田」を含む会員について、「購買」テーブルにレコードがある会員の「合計金額」が高い順に「名前」「合計金額」を表示せよ

---

## 章末課題

**問題**: 実行した際、結果に**欠損が含まれる**クエリを選択せよ

### 選択肢①

```sql
SELECT
    p.*
FROM
    user_mst usr
INNER JOIN purchase p
ON usr.user_id = p.user_id
;
```

### 選択肢②

```sql
SELECT
    usr.user_id
    , p.total_amount
FROM
    user_mst usr
INNER JOIN purchase p
ON usr.user_id = p.user_id
;
```

### 選択肢③

```sql
SELECT
    p.*
FROM
    user_mst usr
LEFT JOIN purchase p
ON usr.user_id = p.user_id
WHERE p.receive_dt IS NOT NULL
;
```

### 選択肢④

```sql
SELECT
    usr.user_id
    , p.total_amount
FROM
    user_mst usr
LEFT JOIN purchase p
ON usr.user_id = p.user_id
WHERE p.total_amount IS NOT NULL
;
```

---

### 章末課題 解答と解説

#### 解答

**選択肢③** と **選択肢④** は、結果に欠損が含まれる**可能性がある**ように見えるが、WHERE句でNULLを除外しているため、**実際には欠損は含まれない**。

**正解は、どの選択肢も結果に欠損を含まない**（ただし、問題の意図によっては異なる解釈がありうる）

しかし、**LEFT JOINを使用した場合にNULLが発生する可能性がある**という観点では、**選択肢③と④がLEFT JOINを使用している**ため、これらが「欠損を含むクエリ」の候補となる。

---

#### 各選択肢の詳細解説

##### 選択肢① - INNER JOIN + p.*

```sql
SELECT
    p.*
FROM
    user_mst usr
INNER JOIN purchase p
ON usr.user_id = p.user_id
;
```

**結果**: 欠損なし

**理由**:
- INNER JOINは両方のテーブルに存在するデータのみを返す
- purchaseテーブルのuser_id=17は、user_mstに存在しないため結果から除外される
- 結合に成功した行のみが返されるため、NULLは発生しない

---

##### 選択肢② - INNER JOIN + 特定カラム

```sql
SELECT
    usr.user_id
    , p.total_amount
FROM
    user_mst usr
INNER JOIN purchase p
ON usr.user_id = p.user_id
;
```

**結果**: 欠損なし

**理由**:
- 選択肢①と同様、INNER JOINを使用
- 両テーブルで一致するデータのみが返される
- total_amountがNULLの行があっても、それはデータの欠損ではなく元データの状態

---

##### 選択肢③ - LEFT JOIN + WHERE IS NOT NULL

```sql
SELECT
    p.*
FROM
    user_mst usr
LEFT JOIN purchase p
ON usr.user_id = p.user_id
WHERE p.receive_dt IS NOT NULL
;
```

**結果**: 欠損なし（WHERE句でフィルタリングされるため）

**理由**:
- LEFT JOINは左テーブル（user_mst）の全行を保持
- 購買履歴がない会員は、purchaseテーブルのカラムがNULLになる
- **しかし**、`WHERE p.receive_dt IS NOT NULL`でNULL行が除外される
- 結果として、receive_dtに値がある行のみが返される

**ポイント**: LEFT JOINを使用しても、WHERE句でNULLを除外しているため、最終結果には欠損が含まれない

---

##### 選択肢④ - LEFT JOIN + WHERE IS NOT NULL

```sql
SELECT
    usr.user_id
    , p.total_amount
FROM
    user_mst usr
LEFT JOIN purchase p
ON usr.user_id = p.user_id
WHERE p.total_amount IS NOT NULL
;
```

**結果**: 欠損なし（WHERE句でフィルタリングされるため）

**理由**:
- 選択肢③と同様の理由
- LEFT JOINでNULLが発生する可能性があるが、WHERE句で除外される

---

#### 補足：WHERE句がない場合のLEFT JOIN

もし選択肢③④からWHERE句を除外した場合：

```sql
-- WHERE句なしの場合
SELECT
    usr.user_id
    , p.total_amount
FROM
    user_mst usr
LEFT JOIN purchase p
ON usr.user_id = p.user_id
;
```

この場合、**購買履歴のない会員**（user_id: 2, 4, 7, 9, 11, 12, 13, 15）の行で、`p.total_amount`が**NULL**（欠損）となる。

| user_id | total_amount |
|:---:|:---:|
| 1 | 2000 |
| 1 | 1000 |
| 2 | **NULL** |
| 3 | 9000 |
| 4 | **NULL** |
| ... | ... |

---

#### まとめ：JOINと欠損の関係

| JOINの種類 | 欠損（NULL）の発生 |
|:---|:---|
| INNER JOIN | 発生しない（一致する行のみ返す） |
| LEFT JOIN | 右テーブルに一致がない場合、右側のカラムがNULLになる |
| RIGHT JOIN | 左テーブルに一致がない場合、左側のカラムがNULLになる |
| FULL JOIN | 両方のテーブルで一致がない場合、NULLになる |

**WHERE句でNULLを除外すると、外部結合でもNULLを含まない結果を得られる**

---

## （参考）CROSS JOIN

### CROSS JOINとは

**CROSS JOIN（交差結合）は、複数テーブルのレコードのすべての組み合わせを取得する結合である**

#### 例：商品データと色データを交差結合する

**商品データ**

| 商品コード | 商品名 | 単価 |
|:---:|:---|:---:|
| 10 | 鉛筆 | 10 |
| 20 | ボールペン | 100 |
| 30 | マーカー | 150 |

**色データ**

| 色コード | 商品名 |
|:---:|:---|
| 100 | 黒 |
| 200 | 赤 |
| 300 | 青 |

**↓ 結合後**

| 商品コード | 商品名 | 単価 | 色コード | 商品名 |
|:---:|:---|:---:|:---:|:---|
| 10 | 鉛筆 | 10 | 100 | 黒 |
| 10 | 鉛筆 | 10 | 200 | 赤 |
| 10 | 鉛筆 | 10 | 300 | 青 |
| 20 | ボールペン | 100 | 100 | 黒 |
| 20 | ボールペン | 100 | 200 | 赤 |
| 20 | ボールペン | 100 | 300 | 青 |
| 30 | マーカー | 150 | 100 | 黒 |
| 30 | マーカー | 150 | 200 | 赤 |
| 30 | マーカー | 150 | 300 | 青 |

### 基本構文

- ONは指定しないことが多い

```sql
SELECT
    * 
FROM 
    左テーブル
CROSS JOIN
    右テーブル
;
```

---

### CROSS JOIN 練習問題

**問題**: 「会員」テーブルと「購買」テーブルを CROSS JOIN し、「個人ID」「購買ID」を出力する

#### 解答

```sql
SELECT
    u.user_id
    , p.sales_id
FROM
    user_mst u
CROSS JOIN purchase p
;
```

#### 実行結果

- 15 × 12 = **180レコード**が抽出される

| 個人ID | 購買ID |
|:---:|:---:|
| 1 | 10001 |
| 1 | 10002 |
| 1 | 10003 |
| 1 | 10004 |
| 1 | 10005 |
| 1 | 10006 |
| 1 | 10007 |
| 1 | 10008 |
| 1 | 10009 |
| 1 | 10010 |
| 1 | 10011 |
| 1 | 10012 |
| （以下略） | |

---

## まとめ

| 概念 | 説明 |
|:---|:---|
| **JOIN** | 複数のテーブルを横に結合する |
| **INNER JOIN** | 両方のテーブルに存在するデータのみ残す |
| **LEFT JOIN** | 左テーブルを基準に結合（右にないデータはNULL） |
| **RIGHT JOIN** | 右テーブルを基準に結合（左にないデータはNULL） |
| **FULL JOIN** | 両方のテーブルの全データを残す |
| **CROSS JOIN** | すべての組み合わせを生成 |
| **UNION** | 複数のクエリ結果を縦に結合（重複削除） |
| **UNION ALL** | 複数のクエリ結果を縦に結合（重複許可） |
| **副問い合わせ** | クエリの中にクエリをネストする |
| **WITH句** | 一時テーブルを定義して再利用する |

---

*Copyright © 2025 Accenture. All rights reserved.*