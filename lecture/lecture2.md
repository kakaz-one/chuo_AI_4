# 第2回 プログラミング入門 まとめ

## 1. 演算

### 1.1 四則演算と基本演算子

Pythonで使用できる主な演算子:

| 記号 | 演算 | 例 | 結果 |
|------|------|-----|------|
| + | 加算 | 2 + 2 | 4 |
| - | 減算 | 12 - 3 | 9 |
| * | 乗算 | 12 * 3 | 36 |
| / | 除算 | 16 / 5 | 3.2 |
| // | 整数除算 | 16 // 5 | 3 |
| % | 剰余 | 16 % 5 | 1 |
| ** | べき乗 | 2 ** 5 | 32 |

### 1.2 演算子の優先順位

- 一般的な数式と同様の優先順位（乗除→加減）
- 優先順位を変更するには丸括弧 `()` を使用

```python
1 + 2 * 3      # 結果: 7
(1 + 2) * 3    # 結果: 9
```

---

## 2. 変数

### 2.1 変数の定義

`=` を使って数値や文字列を変数に代入する:

```python
x = 1
y = 2.5
z = 'Python'
```

### 2.2 変数を使った演算

#### 基本的な演算
```python
pi = 3.141592
r = 6378.1
c = 2 * pi * r  # 結果を変数に代入
```

#### 累積演算子

| 記号 | 演算 | 例 | 意味 |
|------|------|-----|------|
| += | 加算代入 | a += 100 | a = a + 100 |
| -= | 減算代入 | a -= 10 | a = a - 10 |
| *= | 乗算代入 | a *= 2 | a = a * 2 |
| /= | 除算代入 | a /= 5 | a = a / 5 |
| //= | 整数除算代入 | a //= 3 | a = a // 3 |
| %= | 剰余代入 | a %= 4 | a = a % 4 |
| **= | べき乗代入 | a **= 2 | a = a ** 2 |

### 2.3 変数名のルール

**3つの基本ルール:**
1. 数値から始まる変数名は定義できない
2. 大文字と小文字は区別される
3. Pythonの予約語は使えない

**予約語の例:**
```python
import keyword
print(keyword.kwlist)
# ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 
#  'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 
#  'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 
#  'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
```

**変数名のベストプラクティス:**
- 組み込み関数を上書きしない
- わかりやすい名前をつける
- 短い名前にする
- スネークケース（小文字+アンダースコア）を使用

```python
my_lucky_number = 1  # 良い例
```

---

## 3. 文字列

### 3.1 Pythonの主なデータ型

| データ型 | イミュータブル | ミュータブル | イテラブル | 例 |
|----------|---------------|-------------|-----------|-----|
| 文字列 | ○ | - | ○ | 'Accenture' |
| リスト | - | ○ | ○ | [1,2,3] |
| タプル | ○ | - | ○ | ('Accenture', 2005) |

# Pythonにおけるイミュータブル、ミュータブル、イテラブル

## イミュータブル (Immutable)

**変更不可能なオブジェクト**のことです。一度作成されると、その値を変更できません。

### 主なイミュータブルな型

- `int`, `float`, `complex` (数値型)
- `str` (文字列)
- `tuple` (タプル)
- `frozenset` (凍結集合)
- `bool` (真偽値)

### 例

```python
# 文字列は変更できない
s = "hello"
# s[0] = "H"  # エラー!

# 新しいオブジェクトが作られる
s = s.upper()  # "HELLO"

# タプルも変更できない
t = (1, 2, 3)
# t[0] = 10  # エラー!
```

## ミュータブル (Mutable)

**変更可能なオブジェクト**のことです。作成後も内容を変更できます。

### 主なミュータブルな型

- `list` (リスト)
- `dict` (辞書)
- `set` (集合)
- ユーザー定義クラスのインスタンス(通常)

### 例

```python
# リストは変更できる
lst = [1, 2, 3]
lst[0] = 10  # OK
lst.append(4)  # OK
print(lst)  # [10, 2, 3, 4]

# 辞書も変更できる
d = {"a": 1}
d["b"] = 2  # OK
```

## イテラブル (Iterable)

**繰り返し処理できるオブジェクト**のことです。`for`ループで要素を1つずつ取り出せます。

### 主なイテラブルな型

- `list`, `tuple`, `str`, `dict`, `set`
- `range`, `file`オブジェクト
- ジェネレータ

### 例

```python
# すべてイテラブル
for item in [1, 2, 3]:  # リスト
    print(item)

for char in "hello":  # 文字列
    print(char)

for key in {"a": 1, "b": 2}:  # 辞書
    print(key)

for num in range(5):  # range
    print(num)
```

## 重要なポイント

- **イミュータブルとミュータブルは排他的**な概念(どちらか一方)
- **イテラブルは独立した概念**で、イミュータブルでもミュータブルでもイテラブルになりえます
  - 文字列: イミュータブル + イテラブル
  - リスト: ミュータブル + イテラブル
  - 整数: イミュータブル + 非イテラブル

### 3.2 文字列の定義

単引用符 `'` または二重引用符 `"` で囲む:

```python
'spam eggs'
"spam eggs"
```

#### エスケープシーケンス

引用符を文字列に含める場合:

```python
'doesn\'t'    # バックスラッシュでエスケープ
"doesn't"     # 異なる引用符を使用
```

#### 三連引用符（複数行文字列）

```python
"""
おはようございます。
今日は天気がいいですね。
今日もよろしくお願いします。
"""
```
# Pythonのエスケープシーケンスと三連引用符

## エスケープシーケンス (Escape Sequence)

**特殊な文字を表現するために使う記法**で、バックスラッシュ`\`で始まります。

### 主なエスケープシーケンス

```python
# 改行
print("Hello\nWorld")
# 出力:
# Hello
# World

# タブ
print("Name:\tJohn")
# 出力: Name:    John

# バックスラッシュ
print("C:\\Users\\Documents")
# 出力: C:\Users\Documents

# シングルクォート
print('It\'s a pen')
# 出力: It's a pen

# ダブルクォート
print("He said \"Hello\"")
# 出力: He said "Hello"

# キャリッジリターン
print("ABC\rXY")
# 出力: XYC

# バックスペース
print("Hello\b World")
# 出力: Hell World
```

### よく使うエスケープシーケンス一覧

- `\n` : 改行（newline）
- `\t` : タブ（tab）
- `\\` : バックスラッシュ
- `\'` : シングルクォート
- `\"` : ダブルクォート
- `\r` : キャリッジリターン
- `\b` : バックスペース

### Raw文字列（エスケープ無効化）

`r`をつけるとエスケープシーケンスが無効になります。

```python
# 通常の文字列
print("C:\new\test")  # \nが改行として解釈される

# Raw文字列
print(r"C:\new\test")  # そのまま出力: C:\new\test

# 正規表現でよく使う
import re
pattern = r"\d+\.\d+"  # 数字.数字のパターン
```

## 三連引用符（複数行文字列）

**複数行にわたる文字列を簡単に書ける**記法です。`'''`または`"""`を使います。

### 基本的な使い方

```python
# シングルクォート3つ
text1 = '''これは
複数行の
文字列です'''

# ダブルクォート3つ
text2 = """これも
複数行の
文字列です"""

print(text1)
# 出力:
# これは
# 複数行の
# 文字列です
```

### 利点

```python
# 引用符をエスケープ不要
message = """He said "Hello" and she said 'Hi'"""
print(message)
# 出力: He said "Hello" and she said 'Hi'

# 改行を\nで書く必要がない
poem = """春は曙
夏は夜
秋は夕暮れ
冬はつとめて"""

# 長いテキストを読みやすく書ける
html = """
<html>
    <body>
        <h1>タイトル</h1>
    </body>
</html>
"""
```

### 注意点

```python
# インデントもそのまま含まれる
text = """
    これは
    インデント付き
    """
print(repr(text))
# 出力: '\n    これは\n    インデント付き\n    '

# インデントを削除したい場合
from textwrap import dedent

text = dedent("""
    これは
    インデント削除
    """)
print(repr(text))
# 出力: '\nこれは\nインデント削除\n'
```

### docstring（ドキュメント文字列）での使用

三連引用符は関数やクラスのドキュメントとしてもよく使われます。

```python
def greet(name):
    """
    挨拶を返す関数
    
    Parameters:
        name (str): 挨拶する相手の名前
    
    Returns:
        str: 挨拶メッセージ
    """
    return f"Hello, {name}!"

# docstringは__doc__属性で取得可能
print(greet.__doc__)
```

### エスケープシーケンスとの組み合わせ

```python
# 三連引用符の中でもエスケープシーケンスは有効
text = """行1\n行2\t タブ付き"""
print(text)
# 出力:
# 行1
# 行2     タブ付き

# Raw文字列と組み合わせも可能
path = r"""C:\Users\Documents\
test.txt"""
```

### 3.3 文字列の連結

#### + 演算子による連結
```python
'*' + 10 * (5 * '_' + '*')
# 結果: '*_____*_____*_____*_____*_____*______*_____*_____*_____*_____*'
```

#### 自動連結
```python
'Py' 'thon'  # 結果: 'Python'

# 複数行の場合
('Put several strings within parentheses '
 'to have them joined together.')
```

**注意:** 変数には自動連結は働かない
```python
prefix = 'Py'
prefix + 'thon'  # + 演算子が必要
```

### 3.4 文字列のインデクシング

#### 正のインデックス（左から右）
```python
word = 'python'
word[0]  # 'p'
word[4]  # 'o'
```

#### 負のインデックス（右から左）
```python
word[-1]  # 'n'
word[-2]  # 'o'
word[-6]  # 'p'
```

```
インデックス:  0   1   2   3   4   5
              p   y   t   h   o   n
            -6  -5  -4  -3  -2  -1
```

**注意:** 範囲外のインデックスを指定するとエラー発生

### 3.5 文字列のスライシング

#### 基本構文
```python
文字列[start:stop]  # startからstop-1まで取り出す
```

#### スライシングの例
```python
word = 'python'
word[2:5]   # 'tho'
word[4:]    # 'on'（末尾省略）
word[:2]    # 'py'（先頭省略）
word[-2:]   # 'on'（負のインデックス）
```

#### ステップを指定したスライシング
```python
word[0:6:2]   # 'pto'（2文字ごと）
word[::-1]    # 'nohtyp'（反転）
word[::-2]    # 'nhy'（反転して2文字ごと）
```

**重要な性質:**
```python
word[:i] + word[i:] == word  # 常に真
```

### 3.6 文字列の長さ

```python
word = 'python'
len(word)  # 6
```

### 3.7 文字列は不変（イミュータブル）

```python
word = 'python'
word[0] = 'j'  # エラー発生！
```

### 3.8 文字列と数値の変換

#### データ型の確認
```python
type(変数)  # データ型を返す
```

#### 型変換（キャスト）
```python
# 文字列を整数に
12 + int('34')      # 46

# 整数を文字列に
str(12) + '34'      # '1234'

# 異なる数値型同士は演算可能
a, b = 12, 3.4
a + b               # 15.4（int + float）
```

---

## 4. リストとタプル

### 4.1 リスト（list）

#### リストの特徴
- 異なる型の要素を含むことができる
- 多くの連続したデータを扱える
- 要素の検索、追加、削除が容易
- **変更可能（ミュータブル）**

#### リストの定義
```python
[要素1, 要素2, ..., 要素n]

# 例
[1, 2.0, 'Python', 'Java', (1, 2)]
```

#### インデクシング
```python
squares = [1, 4, 9, 16, 25]
squares[0]    # 1
squares[-2]   # 16
```

#### スライシング
```python
squares[2:]    # [9, 16, 25]
squares[-3:]   # [9, 16, 25]
```

#### リストの連結
```python
squares + [36, 49, 64, 81, 100]
# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

#### 要素の追加（append()メソッド）
```python
cubes = [1, 8, 27, 65, 125]
cubes.append(6**3)
# [1, 8, 27, 65, 125, 216]
```

#### 要素の変更
```python
# インデックスで変更
cubes[3] = 4 ** 3
# [1, 8, 27, 64, 125]

# スライスで変更
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
letters[2:5] = ['C', 'D', 'E']
# ['a', 'b', 'C', 'D', 'E', 'f', 'g']
```

#### 要素の削除
```python
# delを使用
cubes = [1, 8, 27, 65, 125, 216]
del cubes[1]
# [1, 27, 65, 125, 216]

# スライスで削除
letters[2:5] = []
# ['a', 'b', 'f', 'g']

# 全削除
letters[:] = []
# []
```

#### 入れ子のリスト
```python
tokyo = [16.5, 16.3, 17.1, 16.4, 16.4, 15.8, 16.8, 16.5]
akita = [10.0, 10.4, 11.5, 11.2, 10.9, 10.6, 11.8, 12.2]
kumamoto = [16.0, 15.5, 15.9, 16.4, 15.9, 15.6, 17.5, 17.1]

temperatures = [tokyo, akita, kumamoto]
temperatures[1][2]  # 11.5
```

#### 数値リストの統計関数

| 関数 | 機能 |
|------|------|
| `max(リスト)` | 最大値 |
| `min(リスト)` | 最小値 |
| `sum(リスト)` | 合計 |
| `len(リスト)` | 要素数 |

```python
temperatures = [10.0, 10.4, 11.5, 11.2, 10.9, 10.6, 11.8, 12.2]

max(temperatures)  # 12.2
min(temperatures)  # 10.0
sum(temperatures)  # 88.6
len(temperatures)  # 8

# 平均値
sum(temperatures) / len(temperatures)  # 11.075

# statisticsモジュール使用
import statistics
statistics.mean(temperatures)  # 11.075
```

### 4.2 タプル（tuple）

#### タプルの特徴
- リストと似ているが**変更不可（イミュータブル）**
- インデクシング、スライシングは可能
- 任意の型の要素を持てる
- 関連性のあるデータ（名前、性別、年齢など）の管理に使用

#### タプルの作成
```python
# 丸括弧を使用
('Albert', 'Einstein', 'male', 32)

# tuple()関数を使用
tuple(['Albert', 'Einstein', 'male', 32])

# 空タプル
()
tuple()
```

#### 要素の参照
```python
person = ('Albert', 'Einstein', 'male', 32)

# インデックス
person[0]    # 'Albert'

# スライス
person[1:]   # ('Einstein', 'male', 32)
person[:3]   # ('Albert', 'Einstein', 'male')
person[1:3]  # ('Einstein', 'male')
```

#### リストとタプルの変換
```python
# タプルからリストへ
person = ('Albert', 'Einstein', 'male', 32)
list(person)  # ['Albert', 'Einstein', 'male', 32]

# リストからタプルへ
person = ['Albert', 'Einstein', 'male', 32]
tuple(person)  # ('Albert', 'Einstein', 'male', 32)
```

---

## 5. （参考）オブジェクトと変数

### 5.1 オブジェクトとは

- プログラムの操作対象となるデータ
- 数値、文字列、リスト、タプルなどすべてがオブジェクト
- 各オブジェクトは**オブジェクトID**で管理される

### 5.2 変数とオブジェクトの関係

変数はオブジェクトのラベルの役割をする:

```python
X = 12345
Y = 'Python'
Z = ['Python', 'R']
```

実際には変数はオブジェクトIDを参照している。

### 5.3 オブジェクトIDの確認

```python
id(12345)           # 例: 140262809408016
X = 12345; id(X)    # 例: 140262809407856
X2 = 12345; id(X2)  # 例: 140262809410352
X3 = X2; id(X3)     # X2と同じID
```

---

# 練習問題解答

## 練習問題①
変数 diameter と pi を用いて円の面積を求めよ。
```python
diameter = 10
pi = 3.141592

# 半径を求める
radius = diameter / 2

# 円の面積 = π × r²
area = pi * radius ** 2

print(f"円の面積: {area}")
```

**出力結果:**
```
円の面積: 78.5398
```

---

## 練習問題②
偶数番目の文字を抜き出せ。
```python
word = "くせないみかんいる"

# 偶数番目の文字を抽出(インデックスは0始まりなので、1, 3, 5...番目)
even_chars = word[1::2]

print(f"偶数番目の文字: {even_chars}")
```

**出力結果:**
```
偶数番目の文字: せなかんる
```

**解説:** インデックスは0から始まるため、偶数番目(2番目、4番目...)はインデックス1, 3, 5...に該当します。

---

## 練習問題③
リストに100を追加して平均値を求めよ。
```python
l = [0, 5, 70, 75]

# 100を追加
l.append(100)

# 平均値を計算
average = sum(l) / len(l)

print(f"リスト: {l}")
print(f"平均値: {average}")
```

**出力結果:**
```
リスト: [0, 5, 70, 75, 100]
平均値: 50.0
```

---

## 練習問題④
タプルの要素変更を試し、エラーを確認。b と c を結合せよ。
```python
a = (3, 8)
b = (5, 2)
c = (9, 1)

# タプルの要素変更を試みる(エラーが発生する)
try:
    a[0] = 10
except TypeError as e:
    print(f"エラー発生: {e}")

# b と c を結合
combined = b + c

print(f"b と c の結合: {combined}")
```

**出力結果:**
```
エラー発生: 'tuple' object does not support item assignment
b と c の結合: (5, 2, 9, 1)
```

**解説:** タプルはイミュータブル(不変)なので、要素の変更はできません。結合は `+` 演算子で可能です。


---

**Copyright © 2025 Accenture. All rights reserved.**

# 第2回 小課題1 問題解説

## 問1. ミュータブル（変更可能）なデータ型

**問題文:**  
以下のうち、ミュータブル（変更可能）であるデータ型を選択せよ。

1. リスト
2. 文字列
3. タプル
4. 整数

### 解説

Pythonのデータ型は**ミュータブル（変更可能）**と**イミュータブル（変更不可）**に分類されます。

| データ型 | ミュータブル | イミュータブル |
|---------|------------|--------------|
| **リスト** | ✅ | |
| 文字列 | | ✅ |
| タプル | | ✅ |
| 整数 | | ✅ |
| 浮動小数点数 | | ✅ |

**実例:**
```python
# リスト（ミュータブル）- 変更可能
my_list = [1, 2, 3]
my_list[0] = 100  # OK
print(my_list)  # [100, 2, 3]

# 文字列（イミュータブル）- 変更不可
my_str = "hello"
my_str[0] = "H"  # エラー！

# タプル（イミュータブル）- 変更不可
my_tuple = (1, 2, 3)
my_tuple[0] = 100  # エラー！
```

**正解: 1. リスト**

---

## 問2. インデクシング・スライシングができないデータ型

**問題文:**  
以下のうち、インデクシング・スライシングができないデータ型を選択せよ。

1. リスト
2. 文字列
3. タプル
4. 整数

### 解説

インデクシングとスライシングは**シーケンス型**のデータに対して使用できます。

| データ型 | インデクシング可能 | スライシング可能 |
|---------|-----------------|----------------|
| リスト | ✅ | ✅ |
| 文字列 | ✅ | ✅ |
| タプル | ✅ | ✅ |
| **整数** | ❌ | ❌ |

**実例:**
```python
# リスト
my_list = [1, 2, 3, 4, 5]
print(my_list[0])     # 1
print(my_list[1:3])   # [2, 3]

# 文字列
my_str = "Python"
print(my_str[0])      # 'P'
print(my_str[0:3])    # 'Pyt'

# タプル
my_tuple = (1, 2, 3, 4, 5)
print(my_tuple[0])    # 1
print(my_tuple[1:3])  # (2, 3)

# 整数
num = 12345
print(num[0])         # エラー！
```

**正解: 4. 整数**

---

## 問3. 剰余演算と3の倍数判定

**問題文:**  
以下のコードの結果と解釈として正しいものを選択せよ。

```python
x = 123456789
y = x % 3
print(y)
```

1. 出力は41152263であり、xが3の倍数であることを示している
2. 出力は41152263であり、xが3の倍数ではないことを示している
3. 出力は0であり、xが3の倍数であることを示している
4. 出力は0であり、xが3の倍数ではないことを示している

### 解説

**剰余演算子 `%`** は割り算の余りを返します。

```python
# 剰余演算の例
10 % 3  # 1（10 ÷ 3 = 3 余り 1）
15 % 3  # 0（15 ÷ 3 = 5 余り 0）
16 % 3  # 1（16 ÷ 3 = 5 余り 1）
```

**3の倍数の判定:**
- `x % 3 == 0` → xは3の倍数
- `x % 3 != 0` → xは3の倍数ではない

**実際の計算:**
```python
x = 123456789
y = x % 3
print(y)  # 0

# 検証: 123456789 ÷ 3 = 41152263
# 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45
# 45は3の倍数なので、123456789も3の倍数
```

**正解: 3. 出力は0であり、xが3の倍数であることを示している**

---

## 問4. 数値を文字列に変換

**問題文:**  
以下のコードの最後の出力を '12月' としたい場合に、□に入るコード（関数）として正しいものを選択せよ。

```python
month = 12
□(month) + '月'
```

1. len
2. int
3. str
4. tuple

### 解説

異なるデータ型同士を連結する場合、型を揃える必要があります。

```python
# ❌ エラー例
month = 12
month + '月'  # TypeError: unsupported operand type(s) for +: 'int' and 'str'

# ✅ 正解例
month = 12
str(month) + '月'  # '12月'
```

**各関数の役割:**
- `len()`: 長さ（要素数）を返す
- `int()`: 整数に変換
- `str()`: 文字列に変換
- `tuple()`: タプルに変換

**正解: 3. str**

---

## 問5. 変数の累積計算

**問題文:**  
以下のコードを上から実行した際の最後のaの値として正しいものを選択せよ。

```python
a = 10
i = 1
a = a + i
i = i + 1
a += i
a += a
a
```

### 解説

**ステップバイステップの計算:**

```python
a = 10           # a = 10
i = 1            # i = 1

a = a + i        # a = 10 + 1 = 11
i = i + 1        # i = 1 + 1 = 2

a += i           # a = 11 + 2 = 13
a += a           # a = 13 + 13 = 26

a                # 26
```

**計算過程の表:**

| ステップ | コード | a の値 | i の値 |
|---------|--------|--------|--------|
| 1 | `a = 10` | 10 | - |
| 2 | `i = 1` | 10 | 1 |
| 3 | `a = a + i` | 11 | 1 |
| 4 | `i = i + 1` | 11 | 2 |
| 5 | `a += i` | 13 | 2 |
| 6 | `a += a` | 26 | 2 |

**正解: 4. 26**

---

## 問6. 文字列スライシング（誤りを選択）

**問題文:**  
以下のコードの最後の出力を 'PS' としたい場合に、□に入るコードとして**誤っているもの**を選択せよ。

```python
tool4 = 'Python and SQL'
□
tool4_abbr
```

1. `tool4_abbr = tool4[0] + tool4[11]`
2. `tool4_abbr = tool4[0:12][0] + tool4[0:12][-1]`
3. `tool4_abbr = tool4[0:11:11]`
4. `tool4_abbr = tool4[::-1][2::11][::-1]`

### 解説

**文字列のインデックス確認:**
```
インデックス: 0  1  2  3  4  5  6  7  8  9  10 11 12 13
文字列:      P  y  t  h  o  n     a  n  d     S  Q  L
```

**各選択肢の検証:**

```python
tool4 = 'Python and SQL'

# 1. tool4[0] + tool4[11]
print(tool4[0])     # 'P'
print(tool4[11])    # 'S'
print(tool4[0] + tool4[11])  # 'PS' ✅

# 2. tool4[0:12][0] + tool4[0:12][-1]
print(tool4[0:12])           # 'Python and S'
print(tool4[0:12][0])        # 'P'
print(tool4[0:12][-1])       # 'S'
print(tool4[0:12][0] + tool4[0:12][-1])  # 'PS' ✅

# 3. tool4[0:11:11]
print(tool4[0:11:11])        # 'P' ❌（'PS'にならない）
# インデックス0から10まで、11文字ごと → 'P'のみ

# 4. tool4[::-1][2::11][::-1]
print(tool4[::-1])           # 'LQS dna nohtyP'
print(tool4[::-1][2::11])    # 'SP'
print(tool4[::-1][2::11][::-1])  # 'PS' ✅
```

**正解: 3. `tool4_abbr = tool4[0:11:11]`**（'P'のみで'PS'にならない）

---

## 問7. 文字列の結合スライシング

**問題文:**  
次の文字列から"HelloWorld"を取り出して表示するのに正しいコードを選択せよ。

```python
text = "SayHelloToTheWhoWorldToday"
```

1. `print(text[3:8] + text[-10:-5])`
2. `print(text[3:9] + text[-11:6])`
3. `print(text[4:9] + text[-10:-6])`
4. `print(text[4:10] + text[-11:-5])`

### 解説

**文字列のインデックス確認:**
```
インデックス:  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
文字列:       S  a  y  H  e  l  l  o  T  o  T  h  e  W  h  o  W  o  r  l  d  T  o  d  a  y
負のindex:  -26-25-24-23-22-21-20-19-18-17-16-15-14-13-12-11-10 -9 -8 -7 -6 -5 -4 -3 -2 -1
```

**目標:** "Hello" + "World" = "HelloWorld"

**"Hello"の位置:** インデックス 3～7（3:8）
**"World"の位置:** インデックス 16～20（16:21）

**各選択肢の検証:**

```python
text = "SayHelloToTheWhoWorldToday"

# 1. text[3:8] + text[-10:-5]
print(text[3:8])      # 'Hello'
print(text[-10:-5])   # 'World'
print(text[3:8] + text[-10:-5])  # 'HelloWorld' ✅

# 2. text[3:9] + text[-11:6]
print(text[3:9])      # 'HelloT'
print(text[-11:6])    # '' (空文字列)

# 3. text[4:9] + text[-10:-6]
print(text[4:9])      # 'elloT'
print(text[-10:-6])   # 'Worl'

# 4. text[4:10] + text[-11:-5]
print(text[4:10])     # 'elloTo'
print(text[-11:-5])   # 'oWorld'
```

**正解: 1. `print(text[3:8] + text[-10:-5])`**

---

## 問8. 黄金数の計算

**問題文:**  
黄金比における黄金数を求めるコードとして正しいものを選択せよ。

1. `(1 + 5) ** 0.5 / 2`
2. `(1 + 5 ** 1 / 2) / 2`
3. `1 + 5 ** 0.5 / 2`
4. `(1 + 5 ** 0.5) / 2`

### 解説

**黄金数（黄金比）の定義:**

数式: φ = (1 + √5) / 2 ≈ 1.618...

**各選択肢の計算:**

```python
import math

# 正しい黄金数
golden_ratio = (1 + math.sqrt(5)) / 2
print(f"正しい黄金数: {golden_ratio}")  # 1.618033988749895

# 1. (1 + 5) ** 0.5 / 2
result1 = (1 + 5) ** 0.5 / 2
print(f"選択肢1: {result1}")  # 1.2247... ❌

# 2. (1 + 5 ** 1 / 2) / 2
result2 = (1 + 5 ** 1 / 2) / 2
print(f"選択肢2: {result2}")  # 1.75 ❌

# 3. 1 + 5 ** 0.5 / 2
result3 = 1 + 5 ** 0.5 / 2
print(f"選択肢3: {result3}")  # 2.118... ❌

# 4. (1 + 5 ** 0.5) / 2
result4 = (1 + 5 ** 0.5) / 2
print(f"選択肢4: {result4}")  # 1.618... ✅
```

**演算子の優先順位に注意:**
- `**`（べき乗）は `/`（除算）より優先
- 括弧で優先順位を明示する

**正解: 4. `(1 + 5 ** 0.5) / 2`**

---

## 問9. 偏差値の計算

**問題文:**  
以下のリスト scores は10人のテストの結果である。70点の人の偏差値を求めるコードの□に入るものとして正しいものを選択せよ。

```python
import statistics
scores = [51, 48, 83, 67, 48, 37, 59, 38, 56, 70]
mu = statistics.mean(scores)
sigma = statistics.stdev(scores)
□
```

1. `((70 - sigma) / mu)`
2. `((70 - mu) / sigma) * 10 + 50`
3. `(mu / sigma) * 70`
4. `((70 - mu) / sigma) * 50 + 10`

### 解説

**偏差値の公式:**

偏差値 = (個人の得点 - 平均点) / 標準偏差 × 10 + 50

**数式:**
```
偏差値 = ((x - μ) / σ) × 10 + 50

x: 個人の得点（70点）
μ: 平均点
σ: 標準偏差
```

**実際の計算:**

```python
import statistics

scores = [51, 48, 83, 67, 48, 37, 59, 38, 56, 70]
mu = statistics.mean(scores)      # 55.7
sigma = statistics.stdev(scores)  # 13.92...

# 偏差値の計算
score = 70
deviation = ((score - mu) / sigma) * 10 + 50
print(f"70点の偏差値: {deviation}")  # 約60.2

# 各選択肢の検証
print(((70 - sigma) / mu))              # 選択肢1: 約1.00 ❌
print(((70 - mu) / sigma) * 10 + 50)    # 選択肢2: 約60.2 ✅
print((mu / sigma) * 70)                # 選択肢3: 約280 ❌
print(((70 - mu) / sigma) * 50 + 10)    # 選択肢4: 約61.4 ❌
```

**正解: 2. `((70 - mu) / sigma) * 10 + 50`**

---

## 問10. 調和平均の計算

**問題文:**  
A地点からB地点まで100kmの道のりがある場合に、行きは時速 x km、帰りは時速 y kmで往復したときの調和平均を計算するコードとして正しいものを選択せよ。

1. `(x + y) / 2`
2. `(100 / x) + (100 / y)`
3. `2 / ((1 / x) + (1 / y))`
4. `(x * y) ** (1 / 2)`

### 解説

**調和平均の定義:**

2つの数 x, y の調和平均 = 2 / (1/x + 1/y) = 2xy / (x + y)

**なぜ調和平均を使うのか:**
往復の平均速度を求める場合、算術平均ではなく調和平均を使います。

**実例:**
```python
# 行き: 時速60km、帰り: 時速40km の場合
x = 60
y = 40

# 1. 算術平均（単純平均）- 誤り
arithmetic_mean = (x + y) / 2
print(f"算術平均: {arithmetic_mean} km/h")  # 50 km/h ❌

# 2. (100 / x) + (100 / y) - 時間の合計
time_sum = (100 / x) + (100 / y)
print(f"時間の合計: {time_sum} h")  # 4.167 h ❌

# 3. 調和平均 - 正しい平均速度
harmonic_mean = 2 / ((1 / x) + (1 / y))
print(f"調和平均: {harmonic_mean} km/h")  # 48 km/h ✅

# 別の計算方法
harmonic_mean2 = (2 * x * y) / (x + y)
print(f"調和平均（別式）: {harmonic_mean2} km/h")  # 48 km/h ✅

# 4. 幾何平均
geometric_mean = (x * y) ** 0.5
print(f"幾何平均: {geometric_mean} km/h")  # 48.99 km/h ❌

# 検証
total_distance = 200  # 往復
total_time = (100 / x) + (100 / y)
average_speed = total_distance / total_time
print(f"実際の平均速度: {average_speed} km/h")  # 48 km/h
```

**正解: 3. `2 / ((1 / x) + (1 / y))`**

---

## 解答まとめ

| 問題 | 正解 | キーポイント |
|------|------|------------|
| 問1 | 1. リスト | ミュータブル vs イミュータブル |
| 問2 | 4. 整数 | シーケンス型の理解 |
| 問3 | 3 | 剰余演算（%）と倍数判定 |
| 問4 | 3. str | 型変換 |
| 問5 | 4. 26 | 累積演算子 |
| 問6 | 3 | スライシングの構文 |
| 問7 | 1 | インデックスとスライシング |
| 問8 | 4 | 黄金数の公式と演算子の優先順位 |
| 問9 | 2 | 偏差値の公式 |
| 問10 | 3 | 調和平均の公式 |

---

