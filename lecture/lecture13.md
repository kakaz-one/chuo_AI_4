# 第13回 SQLite関数の活用

ver1.0.2  
最終更新日: 2025年12月25日

---

## 目次

1. [主なSQLite関数](#主なsqlite関数)
2. [数値の処理](#数値の処理)
3. [日付/時刻の処理](#日付時刻の処理)
4. [文字列の処理](#文字列の処理)
5. [型変換](#型変換)

---

## 主なSQLite関数

SQLite で利用する主要な関数の一覧を示す。

| 主な処理の対象 | 関数 | 処理 |
|:--|:--|:--|
| 数値 | SUM / TOTAL | 合計を取得する |
| 数値 | COUNT | レコード数をカウントする |
| 数値 | AVG | 平均を取得する |
| 数値 | MAX / MIN | 最大値 / 最小値を取得する |
| 数値 | ROUND | 数値を四捨五入した値を取得する |
| 数値 | ABS | 数値の絶対値を取得する |
| 数値 | RANDOM | 整数の乱数を取得する |
| 日付/時刻 | DATE | 日付を取得する |
| 日付/時刻 | DATETIME | 日付と時刻を取得する |
| 日付/時刻 | JULIANDAY | ユリウス日を取得する |
| 日付/時刻 | STRFTIME | 指定したフォーマットで日付と時刻を取得する |
| 文字列 | LENGTH | 文字列の長さを取得する |
| 文字列 | LOWER / UPPER | 文字列を小文字/大文字にする |
| 文字列 | REPLACE | 文字列を別の文字列に置き換える |
| 文字列 | SUBSTR | 文字列の中から部分文字列を取得する |
| 全般 | CAST | データ型を変換する |
| 全般 | COALESCE | 値がNULLの際に指定した値を返す |

---

## 数値の処理

### 集計関数の使用例

GROUP BY を使わずに SUM や AVG を使って計算することができる。

**ポイント:**
- COUNT関数は指定したカラムのNULLではないレコード数をカウントする
- `COUNT(*)` または `COUNT(1)` で全レコード数を取得できる

**クエリの例:**

```sql
SELECT
    SUM(total_amount) AS 合計
  , AVG(total_amount) AS 平均
  , COUNT(receive_dt) AS レコード数
  , COUNT(*) AS 全レコード数
  , MAX(total_amount) AS 最大
  , MIN(total_amount) AS 最小
FROM
    purchase
;
```

**出力結果:**

| 合計 | 平均 | レコード数 | 全レコード数 | 最大 | 最小 |
|:--|:--|:--|:--|:--|:--|
| 65500 | 5458.333 | 9 | 12 | 10000 | 1000 |

### 四捨五入・絶対値・乱数

関数を利用すると四捨五入、絶対値の取得、乱数の取得ができる。

**ポイント:**
- 乱数は -9223372036854775808 から +9223372036854775807 までの値を取る
- 取得したい範囲は `%` を使って指定できる

**クエリの例:**

```sql
WITH A AS (
    SELECT 
        user_id
      , salary 
      , ROUND(AVG(salary) OVER()) AS avg_salary
    FROM
        user_mst
)
SELECT
    user_id
  , salary
  , salary - avg_salary AS 差分
  , ABS(salary - avg_salary) AS 絶対値
  , RANDOM() % 10 AS 乱数
FROM
    A
;
```

**出力結果:**

| user_id | salary | 差分 | 絶対値 | 乱数 |
|:--|:--|:--|:--|:--|
| 1 | 350 | -31 | 31 | -6 |
| 2 | 280 | -101 | 101 | -3 |
| 3 | 260 | -121 | 121 | 6 |
| 4 | 580 | 199 | 199 | -5 |
| 5 | 320 | -61 | 61 | 1 |
| 6 | 95 | -286 | 286 | -6 |
| 7 | 290 | -91 | 91 | 0 |
| 8 | 520 | 139 | 139 | 4 |
| 9 | 490 | 109 | 109 | 1 |
| 10 | 330 | -51 | 51 | 4 |
| 11 | 240 | -141 | 141 | -7 |
| 12 | 720 | 339 | 339 | 9 |
| 13 | 430 | 49 | 49 | -5 |
| 14 | 210 | -171 | 171 | 8 |
| 15 | 600 | 219 | 219 | -8 |

---

## 日付/時刻の処理

### DATE関数 / DATETIME関数

DATE関数やDATETIME関数を使うと、文字列を日付/時刻として扱うことができるようになる。

**ポイント:**
- PostgreSQL や Redshift ではデータ型としてDATEやDATETIMEが使えるが、SQLite では関数を利用して変換する必要がある
- 変換する文字列を `'YYYY-MM-DD'` の形式にしておく必要がある（フォーマットが異なるとNULLになる）

**クエリの例:**

```sql
SELECT
    DATE(order_dt) AS order_date
  , DATETIME(order_dt) AS order_datetime
  , DATE(receive_dt) - DATE(order_dt) AS diff
FROM purchase
;
```

**出力結果:**

| order_date | order_datetime | diff |
|:--|:--|:--|
| 2017-11-01 | 2017-11-01 00:00:00 | 0 |
| 2017-11-02 | 2017-11-02 00:00:00 | 0 |
| 2017-11-02 | 2017-11-02 00:00:00 | 0 |
| 2017-11-03 | 2017-11-03 00:00:00 | NULL |
| 2017-11-04 | 2017-11-04 00:00:00 | 0 |
| 2017-11-05 | 2017-11-05 00:00:00 | 0 |
| 2017-11-07 | 2017-11-07 00:00:00 | 0 |
| 2017-11-09 | 2017-11-09 00:00:00 | NULL |
| 2017-11-12 | 2017-11-12 00:00:00 | 0 |
| 2017-11-12 | 2017-11-12 00:00:00 | 0 |
| 2017-11-14 | 2017-11-14 00:00:00 | NULL |
| 2017-11-15 | 2017-11-15 00:00:00 | 0 |

### DATE関数 / DATETIME関数の修飾子

DATE関数やDATETIME関数に修飾子(modifier)を使うと、指定した日数・時間の加算や減算ができる。

**ポイント:**
- years、months、days、hours、minutes、seconds を指定する
- 修飾子を複数指定することもできる

**クエリの例:**

```sql
SELECT
    DATE(order_dt, '+2 days') AS date_m
  , DATETIME(order_dt, '-8 hours') AS datetime_m
FROM purchase
;
```

**出力結果:**

| date_m | datetime_m |
|:--|:--|
| 2017-11-03 | 2017-11-01 16:00:00 |
| 2017-11-04 | 2017-11-02 16:00:00 |
| 2017-11-04 | 2017-11-02 16:00:00 |
| 2017-11-05 | 2017-11-03 16:00:00 |
| 2017-11-06 | 2017-11-04 16:00:00 |
| 2017-11-07 | 2017-11-05 16:00:00 |
| 2017-11-09 | 2017-11-07 16:00:00 |
| 2017-11-11 | 2017-11-09 16:00:00 |
| 2017-11-14 | 2017-11-12 16:00:00 |
| 2017-11-14 | 2017-11-12 16:00:00 |
| 2017-11-16 | 2017-11-14 16:00:00 |
| 2017-11-17 | 2017-11-15 16:00:00 |

### JULIANDAY関数

JULIANDAY関数は指定した日付と時刻をユリウス日として取得する。

**ポイント:**
- グレゴリオ暦の紀元前4714年11月24日（ユリウス暦の紀元前4713年1月1日）の正午を基準日とした通算日を取得する
- 単位は日である
- SQLite では日数の差分を取得する際に使うことがある
  - ※Redshift では `datediff関数` を使って日数の差分を求めることができる

**クエリの例:**

```sql
SELECT
    JULIANDAY(receive_dt) - JULIANDAY(order_dt) AS diff
FROM purchase
;
```

**出力結果:**

| diff |
|:--|
| 3.0 |
| 3.0 |
| 3.0 |
| NULL |
| 3.0 |
| 3.0 |
| 3.0 |
| NULL |
| 3.0 |
| 3.0 |
| NULL |
| 3.0 |

### STRFTIME関数

STRFTIME関数を使用すると指定のフォーマットで日付と時刻を取得できる。

**ポイント:**
- 1つ目の引数にフォーマット、2つ目の引数に文字列を指定する
- 3番目以降の引数に修飾子を指定することもできる

**フォーマットの例:**

| フォーマット | 意味 | 範囲 |
|:--|:--|:--|
| %Y | 年 | 0000-9999 |
| %m | 月 | 01-12 |
| %d | 日 | 01-31 |
| %W | 年初からの週数 | 00-53 |
| %j | 年初からの日数 | 001-366 |
| %w | 曜日 | 0(日曜)-6(土曜) |
| %H | 時 | 00-24 |
| %M | 分 | 00-59 |
| %S | 秒 | 00-59 |

**クエリの例:**

```sql
SELECT
    STRFTIME('%d/%m/%Y', order_dt) AS order_date
FROM purchase
;
```

**出力結果:**

| order_date |
|:--|
| 01/11/2017 |
| 02/11/2017 |
| 02/11/2017 |
| 03/11/2017 |
| 04/11/2017 |
| 05/11/2017 |
| 07/11/2017 |
| 09/11/2017 |
| 12/11/2017 |
| 12/11/2017 |
| 14/11/2017 |
| 15/11/2017 |

### 練習問題（日付/時刻）

**問題:** 購買テーブルに現在の年と注文日の年の差分を追加せよ

**【購買(purchase)テーブル】**

| 個人ID | 購買ID | 合計金額 | 注文日 | 受取日 | 差分 |
|:--|:--|:--|:--|:--|:--|
| user_id | sales_id | total_amount | order_dt | receive_dt | diff |
| 10 | 10001 | 5000 | 2017-11-01 | 2017-11-04 | |
| 14 | 10002 | 10000 | 2017-11-02 | 2017-11-05 | |
| 8 | 10003 | 3000 | 2017-11-02 | 2017-11-05 | |
| 1 | 10004 | 2000 | 2017-11-03 | | |
| 6 | 10005 | 3500 | 2017-11-04 | 2017-11-07 | |
| 10 | 10006 | 5000 | 2017-11-05 | 2017-11-08 | |
| 6 | 10007 | 8000 | 2017-11-07 | 2017-11-10 | |
| 6 | 10008 | 6000 | 2017-11-09 | | |
| 5 | 10009 | 3000 | 2017-11-12 | 2017-11-15 | |
| 3 | 10010 | 9000 | 2017-11-12 | 2017-11-15 | |
| 1 | 10011 | 1000 | 2017-11-14 | | |
| 17 | 10012 | 10000 | 2017-11-15 | 2017-11-18 | |

---

## 文字列の処理

文字列の長さの取得や文字列の要素の抽出・置き換えができる。

**ポイント:**
- 複数の関数を組み合わせて使うこともできる

**クエリの例:**

```sql
SELECT
    LENGTH(user_name) AS len_name
  , LENGTH(blood) AS len_blood
  , LOWER(blood) AS blood
  , REPLACE(addr, SUBSTR(addr, -1), '') AS addr
FROM
    user_mst
;
```

**出力結果:**

| len_name | len_blood | blood | addr |
|:--|:--|:--|:--|
| 4 | 1 | a | 東京 |
| 4 | 1 | b | 神奈川 |
| 4 | 2 | ab | 埼玉 |
| 4 | 1 | o | 千葉 |
| 4 | 1 | b | 茨城 |
| 5 | 1 | o | 東京 |
| 4 | 1 | a | 埼玉 |
| 4 | 1 | a | 神奈川 |
| 5 | 1 | b | 埼玉 |
| 4 | 1 | o | 東京 |
| 4 | 2 | ab | 千葉 |
| 4 | 1 | a | 神奈川 |
| 3 | 1 | o | 東京 |
| 4 | 1 | b | 千葉 |
| 4 | 1 | a | 神奈川 |

---

## 型変換

### 使用可能なデータ型

SQLite で使用可能なデータ型を示す。

**ポイント:**
- 多くのデータベースでは、テーブル作成時にデータ型の指定が必須となるが、SQLite ではデータ型の指定は必須ではない
  - SQL から型を自動的に決定する
- SQLite は他の SQL よりもデータ型が少ない
  - BOOLEAN や DATE などがない
  - 日付の処理はdate関数等を利用して行う

**SQLite におけるデータ型:**

| データ型 | 意味 |
|:--|:--|
| NULL | NULL値 |
| INTEGER | 符号付き整数 |
| REAL | 浮動小数点数 |
| TEXT | テキスト |
| BLOB | エンコードされない文字列 |

### CAST関数による型変換

カラムが持つデータ型を変換できる。

**ポイント:**
- 他プログラム言語同様、異なるデータ型同士の演算では型変換をしてデータ型を一致させる必要がある

**基本構文① CAST関数:**

```sql
SELECT
    CAST(カラム名 AS 変換後のデータ型) 
FROM
    テーブル名
;
```

**基本構文② ::演算子（※SQLite では使用できない）:**

```sql
SELECT
    カラム名::変換後のデータ型
FROM
    テーブル名
;
```

### 型変換の例

「会員」テーブルで「身長」と「体重」を「身長／体重」として出力するとともに、BMIを算出する。

**ポイント:**
- `「文字列型 || 文字列型」` で文字列を結合できる

**クエリの例:**

```sql
SELECT
    user_id
  , user_name
  , CAST(height AS TEXT) || '／' || CAST(weight AS TEXT) AS h_w
  , ROUND(weight / (CAST(height AS REAL)/100 * CAST(height AS REAL)/100), 2) AS BMI
FROM
    user_mst
;
```

**出力結果:**

| user_id | user_name | h_w | BMI |
|:--|:--|:--|:--|
| 1 | 浅田平八 | 182／56 | 16.91 |
| 2 | 矢田まゆ | 165／54 | 19.83 |
| 3 | 島田りさ | 152／39 | 16.88 |
| 4 | 水口五郎 | 176／68 | 21.95 |
| 5 | 大和慶事 | 185／73 | 21.33 |
| 6 | 高島亜里沙 | 148／41 | 18.72 |
| 7 | 安田紗江 | 154／47 | 19.82 |
| 8 | 田村哲平 | 178／69 | 21.78 |
| 9 | 五十嵐涼子 | 162／45 | 17.15 |
| 10 | 神田洋介 | 171／63 | 21.55 |
| 11 | 山口美穂 | 169／49 | 17.16 |
| 12 | 坂本卓也 | 164／59 | 21.94 |
| 13 | 辻本隼 | 156／65 | 26.71 |
| 14 | 君島理恵 | 155／42 | 17.48 |
| 15 | 小池隆二 | 153／53 | 22.64 |

### 練習問題（型変換）

**問題:** 「会員」テーブルの「年齢」に単位を付け、「〇歳」と出力する

- 「個人ID」、「性別」、「年齢」のみを表示する

**【会員(user_mst)テーブル】**

| 個人ID | 名前 | 性別 | 年齢 | 血液型 | 身長 | 体重 | 住所 | 結婚回数 | 年収 |
|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|
| user_id | user_name | gender | age | blood | height | weight | addr | marriage | salary |
| 1 | 浅田平八 | 男 | 28 | A | 182 | 56 | 東京都 | 0 | 350 |
| 2 | 矢田まゆ | 女 | 30 | B | 165 | 54 | 神奈川県 | 1 | 280 |
| 3 | 島田りさ | 女 | 24 | AB | 152 | 39 | 埼玉県 | 0 | 260 |
| 4 | 水口五郎 | 男 | 35 | O | 176 | 68 | 千葉県 | 0 | 580 |
| 5 | 大和慶事 | 男 | 22 | B | 185 | 73 | 茨城県 | 0 | 320 |
| 6 | 高島亜里沙 | 女 | 18 | O | 148 | 41 | 東京都 | 0 | 95 |
| 7 | 安田紗江 | 女 | 28 | A | 154 | 47 | 埼玉県 | 0 | 290 |
| 8 | 田村哲平 | 男 | 32 | A | 178 | 69 | 神奈川県 | 0 | 520 |
| 9 | 五十嵐涼子 | 女 | 29 | B | 162 | 45 | 埼玉県 | 1 | 490 |
| 10 | 神田洋介 | 男 | 25 | O | 171 | 63 | 東京都 | 0 | 330 |
| 11 | 山口美穂 | 女 | 19 | AB | 169 | 49 | 千葉県 | 0 | 240 |
| 12 | 坂本卓也 | 男 | 39 | A | 164 | 59 | 神奈川県 | 2 | 720 |
| 13 | 辻本隼 | 男 | 26 | O | 156 | 65 | 東京都 | 0 | 430 |
| 14 | 君島理恵 | 女 | 27 | B | 155 | 42 | 千葉県 | 0 | 210 |
| 15 | 小池隆二 | 男 | 24 | A | 153 | 53 | 神奈川県 | 0 | 600 |

---

## 章末課題

自分の誕生日から今日までの日数を算出するクエリとして正しいものを選択せよ。

※以下は1989年6月18日生まれの人の例とする

**① SELECT**
```sql
SELECT
    DATE('now') - DATE('1989-06-18');
```

**② SELECT**
```sql
SELECT 
    JULIANDAY('now') - JULIANDAY('1989-06-18');
```

**③ SELECT**
```sql
SELECT
    (STRFTIME('%Y%m%d', 'now') - STRFTIME('%Y%m%d', '1989-06-18')) / 10000;
```

**④ SELECT**
```sql
SELECT
    SUBSTR(DATE('now'), 1, 4) - SUBSTR('1989-06-18', 1, 4);
```

---

### 解答

**正解: ②**

```sql
SELECT 
    JULIANDAY('now') - JULIANDAY('1989-06-18');
```

---

### 解説

各選択肢について詳しく見ていきます。

**① DATE関数同士の引き算**

```sql
SELECT DATE('now') - DATE('1989-06-18');
```

DATE関数は `'YYYY-MM-DD'` 形式の**文字列**を返します。SQLiteでは文字列同士の引き算を行うと、文字列の先頭から数値として解釈できる部分のみが計算に使われます。例えば `'2025-12-28'` は `2025` として解釈されるため、この方法では**年の差分**しか取得できず、正確な日数は計算できません。

**② JULIANDAY関数同士の引き算（正解）**

```sql
SELECT JULIANDAY('now') - JULIANDAY('1989-06-18');
```

JULIANDAY関数は日付を**ユリウス日（通算日数）**として返します。これは紀元前4714年11月24日正午からの経過日数を浮動小数点数で表したものです。2つの日付のユリウス日の差を取ることで、**正確な日数の差分**を計算できます。これがSQLiteで日数差を求める標準的な方法です。

**③ STRFTIME関数で数値化して計算**

```sql
SELECT (STRFTIME('%Y%m%d', 'now') - STRFTIME('%Y%m%d', '1989-06-18')) / 10000;
```

この方法では日付を `'YYYYMMDD'` 形式の数値（例: 20251228）に変換して引き算し、10000で割っています。しかし、これは**年の差分の近似値**を求めているだけで、正確な日数は計算できません。例えば `20251228 - 19890618 = 360610` を `10000` で割ると `36.061` となり、これは日数ではありません。

**④ SUBSTR関数で年だけを抽出**

```sql
SELECT SUBSTR(DATE('now'), 1, 4) - SUBSTR('1989-06-18', 1, 4);
```

この方法では日付文字列から**年の部分（4文字）だけ**を抽出して引き算しています。結果は `2025 - 1989 = 36` のように**年数の差**になり、日数は計算できません。

---

### まとめ

| 選択肢 | 結果 | 正確な日数か |
|:--|:--|:--|
| ① DATE関数の引き算 | 年の差（数値として解釈） | ✗ |
| ② JULIANDAY関数の引き算 | 正確な日数 | ✓ |
| ③ STRFTIME + 計算 | 意味のない数値 | ✗ |
| ④ SUBSTR関数 | 年の差のみ | ✗ |

SQLiteで**日付間の日数差**を正確に求めるには、**JULIANDAY関数**を使用するのが正しい方法です。

---

*Thank you!*